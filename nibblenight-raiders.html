<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NibbleNight Raiders</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a14;
    font-family: 'Nunito', sans-serif;
    overflow: hidden;
    color: #fff;
    width: 100vw;
    height: 100vh;
  }

  canvas { display: block; position: absolute; top: 0; left: 0; }

  /* ‚îÄ‚îÄ SCREENS ‚îÄ‚îÄ */
  .screen {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 10;
  }
  .screen.hidden { display: none; }

  /* ‚îÄ‚îÄ CHARACTER SELECT ‚îÄ‚îÄ */
  #selectScreen {
    background: radial-gradient(ellipse at 50% 30%, #1a1030 0%, #0a0a14 70%);
  }
  .game-title {
    font-family: 'Fredoka One', cursive;
    font-size: clamp(2.5rem, 6vw, 5rem);
    color: #c9a0ff;
    text-shadow: 0 0 40px #8b5cf680, 0 0 80px #8b5cf640;
    letter-spacing: 2px;
    margin-bottom: 0.3em;
    animation: glow 3s ease-in-out infinite alternate;
  }
  @keyframes glow {
    from { text-shadow: 0 0 30px #8b5cf660, 0 0 60px #8b5cf630; }
    to   { text-shadow: 0 0 60px #c9a0ffaa, 0 0 120px #8b5cf660; }
  }
  .subtitle {
    color: #9ca3af; font-size: 1rem; font-weight: 600;
    letter-spacing: 3px; text-transform: uppercase;
    margin-bottom: 2.5em;
  }
  .select-label {
    color: #e2c8ff; font-size: 1.1rem; font-weight: 700;
    margin-bottom: 1.2em; letter-spacing: 1px;
  }
  .character-grid {
    display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;
    max-width: 900px; padding: 0 1rem;
  }
  .char-card {
    background: rgba(255,255,255,0.04);
    border: 2px solid rgba(255,255,255,0.08);
    border-radius: 20px;
    padding: 1.5rem 1.2rem;
    width: 155px; cursor: pointer;
    transition: all 0.25s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .char-card::before {
    content: '';
    position: absolute; inset: 0;
    background: var(--glow);
    opacity: 0;
    transition: opacity 0.3s;
    border-radius: 18px;
  }
  .char-card:hover::before, .char-card.selected::before { opacity: 0.12; }
  .char-card:hover, .char-card.selected {
    border-color: var(--color);
    transform: translateY(-4px);
    box-shadow: 0 12px 30px rgba(0,0,0,0.4), 0 0 20px var(--shadow);
  }
  .char-card.selected { transform: translateY(-6px) scale(1.04); }
  .char-emoji { font-size: 3rem; margin-bottom: 0.4em; display: block; }
  .char-name {
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; color: var(--color);
    margin-bottom: 0.4em;
  }
  .char-desc { font-size: 0.72rem; color: #9ca3af; line-height: 1.4; }
  .char-stat {
    margin-top: 0.7em;
    font-size: 0.68rem; color: #6b7280;
    display: flex; justify-content: space-between;
  }
  .stat-bar {
    height: 3px; background: rgba(255,255,255,0.08);
    border-radius: 2px; margin-top: 0.5em; overflow: hidden;
  }
  .stat-fill { height: 100%; border-radius: 2px; background: var(--color); }

  .start-btn {
    margin-top: 2rem;
    font-family: 'Fredoka One', cursive;
    font-size: 1.4rem;
    padding: 0.8em 3em;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg, #8b5cf6, #c084fc);
    color: white;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 8px 25px rgba(139,92,246,0.4);
    letter-spacing: 1px;
  }
  .start-btn:hover { transform: scale(1.06); box-shadow: 0 12px 35px rgba(139,92,246,0.6); }
  .start-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

  /* ‚îÄ‚îÄ HUD ‚îÄ‚îÄ */
  #hud {
    position: absolute; inset: 0; pointer-events: none; z-index: 5;
  }
  .hud-top {
    position: absolute; top: 1rem; left: 50%;
    transform: translateX(-50%);
    display: flex; align-items: center; gap: 1.5rem;
  }
  .hp-bar-wrap {
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 20px; padding: 4px 10px;
    display: flex; align-items: center; gap: 8px;
    min-width: 200px;
  }
  .hp-icon { font-size: 1rem; }
  .hp-track {
    flex: 1; height: 10px;
    background: rgba(255,255,255,0.1);
    border-radius: 5px; overflow: hidden;
  }
  .hp-fill {
    height: 100%; border-radius: 5px;
    background: linear-gradient(90deg, #ef4444, #f87171);
    transition: width 0.2s;
  }
  .hp-text { font-size: 0.75rem; font-weight: 700; white-space: nowrap; }

  .timer-box {
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 20px; padding: 4px 16px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.3rem; color: #c9a0ff;
  }

  .xp-bar-wrap {
    position: absolute; bottom: 0; left: 0; right: 0;
    height: 6px; background: rgba(0,0,0,0.4);
  }
  .xp-fill {
    height: 100%;
    background: linear-gradient(90deg, #a855f7, #ec4899);
    transition: width 0.3s ease;
  }

  .level-badge {
    position: absolute; bottom: 1rem; left: 50%;
    transform: translateX(-50%);
    font-family: 'Fredoka One', cursive;
    font-size: 0.9rem; color: #c9a0ff;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(139,92,246,0.4);
    border-radius: 20px; padding: 3px 14px;
  }

  .kill-counter {
    position: absolute; top: 1rem; right: 1rem;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px; padding: 5px 12px;
    font-size: 0.85rem; font-weight: 700;
    color: #fbbf24;
  }

  .mute-btn {
    position: absolute; top: 1rem; left: 1rem;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px; padding: 5px 10px;
    font-size: 1rem; cursor: pointer;
    pointer-events: all;
    transition: all 0.15s;
    color: white; line-height: 1;
  }
  .mute-btn:hover { background: rgba(255,255,255,0.1); }

  /* ‚îÄ‚îÄ LEVEL UP ‚îÄ‚îÄ */
  #levelupScreen {
    background: rgba(5, 3, 15, 0.88);
    backdrop-filter: blur(8px);
  }
  .levelup-title {
    font-family: 'Fredoka One', cursive;
    font-size: 2.5rem; color: #c9a0ff;
    text-shadow: 0 0 30px #8b5cf6;
    margin-bottom: 0.3em;
    animation: pulse 1s ease-in-out infinite;
  }
  @keyframes pulse {
    0%,100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  .levelup-sub { color: #9ca3af; margin-bottom: 2em; font-size: 1rem; }
  .upgrade-cards {
    display: flex; gap: 1.2rem; flex-wrap: wrap; justify-content: center;
    max-width: 800px;
  }
  .upgrade-card {
    background: rgba(255,255,255,0.04);
    border: 2px solid rgba(139,92,246,0.3);
    border-radius: 18px; padding: 1.5rem 1.2rem;
    width: 210px; cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    pointer-events: all;
  }
  .upgrade-card:hover {
    border-color: #8b5cf6;
    background: rgba(139,92,246,0.12);
    transform: translateY(-4px);
    box-shadow: 0 10px 30px rgba(139,92,246,0.3);
  }
  .upgrade-icon { font-size: 2.5rem; margin-bottom: 0.5em; }
  .upgrade-name {
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; color: #e9d5ff; margin-bottom: 0.4em;
  }
  .upgrade-desc { font-size: 0.8rem; color: #9ca3af; line-height: 1.5; }
  .upgrade-rarity {
    font-size: 0.65rem; font-weight: 700; letter-spacing: 2px;
    text-transform: uppercase; margin-top: 0.6em;
    padding: 2px 8px; border-radius: 10px; display: inline-block;
  }
  .rarity-common { background: rgba(156,163,175,0.2); color: #9ca3af; }
  .rarity-rare { background: rgba(59,130,246,0.2); color: #60a5fa; }
  .rarity-epic { background: rgba(139,92,246,0.2); color: #c084fc; }

  /* ‚îÄ‚îÄ GAME OVER ‚îÄ‚îÄ */
  #gameoverScreen {
    background: rgba(5, 3, 15, 0.93);
    backdrop-filter: blur(12px);
    text-align: center; gap: 1rem;
  }
  .gameover-title {
    font-family: 'Fredoka One', cursive;
    font-size: 4rem; color: #ef4444;
    text-shadow: 0 0 40px #ef444460;
    margin-bottom: 0.1em;
  }
  .gameover-stats {
    color: #9ca3af; font-size: 1rem;
    line-height: 2.2;
  }
  .gameover-stats span { color: #e9d5ff; font-weight: 700; }
  .retry-btn {
    margin-top: 1.5rem;
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem; padding: 0.7em 2.5em;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg, #ef4444, #f97316);
    color: white; cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 6px 20px rgba(239,68,68,0.4);
  }
  .retry-btn:hover { transform: scale(1.06); }

  /* ‚îÄ‚îÄ ENERGY / SUPERMOVE HUD ‚îÄ‚îÄ */
  .hud-bottom-left {
    position: absolute; bottom: 1.8rem; left: 1rem;
    display: flex; flex-direction: column; gap: 6px; align-items: flex-start;
  }
  .energy-wrap {
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 20px; padding: 4px 10px;
    display: flex; align-items: center; gap: 8px;
    min-width: 160px;
  }
  .energy-track {
    flex: 1; height: 8px;
    background: rgba(255,255,255,0.08);
    border-radius: 4px; overflow: hidden;
  }
  .energy-fill {
    height: 100%; border-radius: 4px;
    background: linear-gradient(90deg, #06b6d4, #a5f3fc);
    transition: width 0.15s ease;
  }
  .energy-fill.charged {
    background: linear-gradient(90deg, #facc15, #fde68a);
    box-shadow: 0 0 8px #facc1580;
    animation: energyPulse 0.6s ease-in-out infinite alternate;
  }
  @keyframes energyPulse {
    from { box-shadow: 0 0 4px #facc1560; }
    to   { box-shadow: 0 0 18px #facc15cc; }
  }
  .super-hint {
    font-size: 0.65rem; font-weight: 800; letter-spacing: 1px;
    color: #fde68a; text-transform: uppercase; white-space: nowrap;
    opacity: 0; transition: opacity 0.3s;
  }
  .super-hint.visible { opacity: 1; animation: hintBounce 0.8s ease-in-out infinite alternate; }
  @keyframes hintBounce {
    from { transform: scale(1); } to { transform: scale(1.08); }
  }
  .super-active-flash {
    position: absolute; inset: 0;
    pointer-events: none; z-index: 4;
    opacity: 0; transition: opacity 0.08s;
  }
  .super-active-flash.show { opacity: 1; }

  /* ‚îÄ‚îÄ GOLD COUNTER ‚îÄ‚îÄ */
  .gold-counter {
    position: absolute; top: 1rem; right: 8rem;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,215,0,0.25);
    border-radius: 12px; padding: 5px 12px;
    font-size: 0.85rem; font-weight: 700;
    color: #fbbf24;
  }

  /* ‚îÄ‚îÄ PAUSE SCREEN ‚îÄ‚îÄ */
  #pauseScreen {
    background: rgba(5,3,15,0.82);
    backdrop-filter: blur(14px);
    gap: 1rem;
    text-align: center;
  }
  .pause-title {
    font-family: 'Fredoka One', cursive;
    font-size: 3rem; color: #c9a0ff;
    text-shadow: 0 0 30px #8b5cf6;
    margin-bottom: 0.5rem;
  }
  .pause-subtitle { color: #6b7280; font-size: 0.85rem; letter-spacing: 2px; margin-bottom: 1.5rem; }
  .pause-btn {
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; padding: 0.65em 2.5em;
    border: none; border-radius: 50px; cursor: pointer;
    transition: all 0.18s; width: 220px; display: block;
    margin: 0 auto 0.5rem;
  }
  .pause-btn:hover { transform: scale(1.05); }
  .pause-btn-resume  { background: linear-gradient(135deg,#8b5cf6,#c084fc); color:#fff; box-shadow:0 5px 18px rgba(139,92,246,0.4); }
  .pause-btn-town    { background: linear-gradient(135deg,#d97706,#fbbf24); color:#fff; box-shadow:0 5px 18px rgba(251,191,36,0.35); }
  .pause-btn-retry   { background: linear-gradient(135deg,#16a34a,#4ade80); color:#fff; box-shadow:0 5px 18px rgba(74,222,128,0.35); }
  .pause-btn-menu    { background: rgba(255,255,255,0.06); color:#9ca3af; border:1px solid rgba(255,255,255,0.1); }
  .pause-controls {
    margin-top: 1rem; color: #4b5563; font-size: 0.72rem;
    line-height: 2; letter-spacing: 0.5px;
  }
  .pause-controls kbd {
    background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12);
    border-radius: 4px; padding: 1px 6px; font-size: 0.7rem; color: #9ca3af;
  }

  /* ‚îÄ‚îÄ TOWN SCREEN ‚îÄ‚îÄ */
  #townScreen {
    background: radial-gradient(ellipse at 50% 20%, #1a1200 0%, #0a0a00 60%, #0a0a14 100%);
    gap: 0; overflow-y: auto; padding: 2rem 1rem;
    justify-content: flex-start;
  }
  .town-title {
    font-family: 'Fredoka One', cursive;
    font-size: clamp(2rem,5vw,3.5rem); color: #fbbf24;
    text-shadow: 0 0 30px #d9770660;
    margin-bottom: 0.2rem;
  }
  .town-sub { color: #78716c; font-size: 0.9rem; letter-spacing: 2px; margin-bottom: 0.4rem; }
  .town-gold {
    font-family: 'Fredoka One', cursive;
    font-size: 1.4rem; color: #fbbf24;
    background: rgba(251,191,36,0.08);
    border: 1px solid rgba(251,191,36,0.2);
    border-radius: 20px; padding: 6px 20px;
    margin-bottom: 1.5rem;
  }
  .town-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
    gap: 0.9rem; max-width: 900px; width: 100%;
    margin-bottom: 1.5rem;
  }
  .town-card {
    background: rgba(255,255,255,0.03);
    border: 2px solid rgba(251,191,36,0.15);
    border-radius: 16px; padding: 1.1rem 1rem;
    text-align: center; transition: all 0.2s;
    position: relative;
  }
  .town-card:not(.maxed):not(.cant-afford) { cursor: pointer; }
  .town-card:not(.maxed):not(.cant-afford):hover {
    border-color: #fbbf24;
    background: rgba(251,191,36,0.07);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  }
  .town-card.cant-afford { opacity: 0.45; }
  .town-card.maxed { border-color: rgba(74,222,128,0.3); opacity: 0.7; }
  .town-icon { font-size: 2rem; margin-bottom: 0.4rem; }
  .town-name { font-family: 'Fredoka One', cursive; font-size: 1rem; color: #fde68a; margin-bottom: 0.3rem; }
  .town-desc { font-size: 0.72rem; color: #78716c; line-height: 1.4; margin-bottom: 0.5rem; }
  .town-cost { font-size: 0.8rem; font-weight: 700; color: #fbbf24; }
  .town-level {
    position: absolute; top: 8px; right: 10px;
    font-size: 0.65rem; font-weight: 800; color: #6b7280;
    letter-spacing: 1px;
  }
  .town-maxed-label { font-size: 0.72rem; color: #4ade80; font-weight: 700; margin-top: 0.2rem; }
  .town-leave-btn {
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem; padding: 0.7em 3em;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg,#8b5cf6,#c084fc);
    color: white; cursor: pointer;
    box-shadow: 0 6px 20px rgba(139,92,246,0.4);
    transition: all 0.2s; margin-top: 0.5rem;
  }
  .town-leave-btn:hover { transform: scale(1.05); }

  /* ‚îÄ‚îÄ FLOATING TEXT ‚îÄ‚îÄ */
  .float-text {
    position: absolute; pointer-events: none;
    font-weight: 800; font-size: 0.85rem; z-index: 6;
    animation: floatUp 1s ease-out forwards;
  }
  @keyframes floatUp {
    from { opacity: 1; transform: translateY(0); }
    to   { opacity: 0; transform: translateY(-60px); }
  }
</style>
</head>
<body>

<!-- CHARACTER SELECT -->
<div class="screen" id="selectScreen">
  <h1 class="game-title">NibbleNight Raiders</h1>
  <p class="subtitle">Roguelite ¬∑ Autobattler ¬∑ Survive the Light</p>
  <p class="select-label">Choose your Raider</p>
  <div class="character-grid" id="charGrid"></div>
  <button class="start-btn" id="startBtn" disabled>Enter the Forest</button>
</div>

<!-- GAME CANVAS -->
<canvas id="gameCanvas"></canvas>

<!-- SUPERMOVE FLASH -->
<div id="superFlash" class="super-active-flash"></div>

<!-- HUD -->
<div class="screen hidden" id="hud">
  <div class="hud-top">
    <div class="hp-bar-wrap">
      <span class="hp-icon">‚ù§Ô∏è</span>
      <div class="hp-track"><div class="hp-fill" id="hpFill" style="width:100%"></div></div>
      <span class="hp-text" id="hpText">100/100</span>
    </div>
    <div class="timer-box" id="timerBox">00:00</div>
  </div>
  <div class="gold-counter" id="goldCounter">ü™ô 0</div>
  <div class="kill-counter" id="killCounter">üíÄ 0</div>
  <button class="mute-btn" id="muteBtn" title="Toggle sound">üîä</button>
  <div class="hud-bottom-left">
    <div class="energy-wrap">
      <span style="font-size:0.9rem">‚ö°</span>
      <div class="energy-track"><div class="energy-fill" id="energyFill" style="width:0%"></div></div>
      <span style="font-size:0.7rem;font-weight:700;color:#9ca3af;white-space:nowrap" id="energyText">0/100</span>
    </div>
    <span class="super-hint" id="superHint">SPACE ‚Äî SUPERMOVE!</span>
  </div>
  <div class="xp-bar-wrap">
    <div class="xp-fill" id="xpFill" style="width:0%"></div>
  </div>
  <div class="level-badge" id="levelBadge">Level 1</div>
</div>

<!-- LEVEL UP -->
<div class="screen hidden" id="levelupScreen">
  <div class="levelup-title">‚¨Ü Level Up!</div>
  <div class="levelup-sub">Choose an upgrade</div>
  <div class="upgrade-cards" id="upgradeCards"></div>
</div>

<!-- PAUSE SCREEN -->
<div class="screen hidden" id="pauseScreen">
  <div class="pause-title">‚è∏ Paused</div>
  <div class="pause-subtitle">GAME PAUSED</div>
  <button class="pause-btn pause-btn-resume"  id="pauseResume">‚ñ∂ Resume</button>
  <button class="pause-btn pause-btn-town"    id="pauseTown">üèò Visit Town</button>
  <button class="pause-btn pause-btn-retry"   id="pauseRetry">‚Ü∫ Restart Run</button>
  <button class="pause-btn pause-btn-menu"    id="pauseMenu">‚Üê Main Menu</button>
  <div class="pause-controls">
    <kbd>WASD</kbd> / <kbd>‚Üë‚Üì‚Üê‚Üí</kbd> Move &nbsp;|&nbsp;
    <kbd>SPACE</kbd> Supermove &nbsp;|&nbsp;
    <kbd>ESC</kbd> Pause
  </div>
</div>

<!-- TOWN SCREEN -->
<div class="screen hidden" id="townScreen">
  <div class="town-title">üèò Nibble Town</div>
  <div class="town-sub">Spend your gold on permanent upgrades</div>
  <div class="town-gold" id="townGoldDisplay">ü™ô 0 gold</div>
  <div class="town-grid" id="townGrid"></div>
  <button class="town-leave-btn" id="townLeaveBtn">Return to Battle ‚Üí</button>
</div>

<!-- GAME OVER -->
<div class="screen hidden" id="gameoverScreen">
  <div class="gameover-title">üíÄ Defeated!</div>
  <div class="gameover-stats" id="gameoverStats"></div>
  <button class="retry-btn" id="retryBtn">Try Again</button>
  <button class="retry-btn" id="visitTownBtn" style="background:linear-gradient(135deg,#d97706,#fbbf24);margin-top:0.5rem;box-shadow:0 6px 20px rgba(251,191,36,0.4)">üèò Visit Town</button>
  <button class="retry-btn" id="menuBtn" style="background:linear-gradient(135deg,#8b5cf6,#c084fc);margin-top:0.5rem;box-shadow:0 6px 20px rgba(139,92,246,0.4)">Main Menu</button>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DATA
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const CHARS = [
  {
    id: 'squirrel', name: 'Laser Squirrel', emoji: 'üêøÔ∏è',
    desc: 'Fires piercing laser beams at enemies',
    color: '#ff9f43', glow: 'rgba(255,159,67,0.3)', shadow: 'rgba(255,159,67,0.5)',
    hp: 100, speed: 210,
    stats: { hp: 60, spd: 80, dmg: 70 },
    weapon: { type: 'laser', damage: 18, cooldown: 0.9, range: 420, pierce: 3, count: 1 },
    ultimate: { name: 'Solar Overcharge', icon: '‚òÄÔ∏è', desc: 'Fires 24 lasers in all directions', color: '#ff9f43',
      activate(p) {
        for (let i = 0; i < 24; i++) spawnProjectile((i/24)*Math.PI*2, { ...p.weapon, damage: p.weapon.damage*2.5, pierce:99, range: p.weapon.range*1.5 });
        triggerSuperFlash('#ff9f43');
      }
    }
  },
  {
    id: 'beaver', name: 'Vampire Beaver', emoji: 'ü¶´',
    desc: 'Bites enemies and steals their life force',
    color: '#c0392b', glow: 'rgba(192,57,43,0.3)', shadow: 'rgba(192,57,43,0.5)',
    hp: 160, speed: 160,
    stats: { hp: 90, spd: 40, dmg: 60 },
    weapon: { type: 'bite', damage: 30, cooldown: 1.1, range: 110, pierce: 1, lifesteal: 0.35 },
    ultimate: { name: 'Blood Frenzy', icon: 'ü©∏', desc: 'Heal 60 HP + deal massive damage in melee range', color: '#ef4444',
      activate(p) {
        player.hp = Math.min(player.maxHp, player.hp + 60);
        spawnFloatText(player.x, player.y - 50, '+60 HP', '#2ecc71');
        for (let i = 0; i < 16; i++) spawnProjectile((i/16)*Math.PI*2, { ...p.weapon, damage: p.weapon.damage*4, pierce:99, range:160 });
        triggerSuperFlash('#ef4444');
      }
    }
  },
  {
    id: 'catthulu', name: 'Cat-thulu', emoji: 'üê±',
    desc: 'Erupts tentacles in all directions',
    color: '#9b59b6', glow: 'rgba(155,89,182,0.3)', shadow: 'rgba(155,89,182,0.5)',
    hp: 120, speed: 175,
    stats: { hp: 70, spd: 55, dmg: 85 },
    weapon: { type: 'tentacle', damage: 22, cooldown: 1.4, range: 190, pierce: 99, count: 8, aoe: true },
    ultimate: { name: 'Void Eruption', icon: 'üåÄ', desc: 'Massive expanding ring of tentacles wipes all nearby enemies', color: '#9b59b6',
      activate(p) {
        for (let w = 0; w < 3; w++) {
          setTimeout(() => {
            for (let i = 0; i < 20; i++) spawnProjectile((i/20)*Math.PI*2 + w*0.1, { ...p.weapon, damage: p.weapon.damage*3, pierce:99, range: (180+w*120) });
          }, w * 120);
        }
        triggerSuperFlash('#9b59b6');
      }
    }
  },
  {
    id: 'cobra', name: 'Chupa-Cobra', emoji: 'üêç',
    desc: 'Sprays rapid poison in a cone',
    color: '#27ae60', glow: 'rgba(39,174,96,0.3)', shadow: 'rgba(39,174,96,0.5)',
    hp: 90, speed: 230,
    stats: { hp: 45, spd: 95, dmg: 65 },
    weapon: { type: 'poison', damage: 7, cooldown: 0.35, range: 240, pierce: 2, count: 3, spread: 0.4 },
    ultimate: { name: 'Venom Nova', icon: '‚ò†Ô∏è', desc: 'Sprays 32 poison shots in all directions, poisoning every enemy on screen', color: '#27ae60',
      activate(p) {
        for (let i = 0; i < 32; i++) spawnProjectile((i/32)*Math.PI*2, { ...p.weapon, damage: p.weapon.damage*2, pierce:99, range: 800 });
        enemies.forEach(e => { e.poisoned = (e.poisoned||0) + 6; });
        triggerSuperFlash('#27ae60');
      }
    }
  },
  {
    id: 'honker', name: 'Honkergeist', emoji: 'ü™ø',
    desc: 'Launches spectral projectiles in 4 directions',
    color: '#74b9ff', glow: 'rgba(116,185,255,0.3)', shadow: 'rgba(116,185,255,0.5)',
    hp: 100, speed: 195,
    stats: { hp: 60, spd: 65, dmg: 75 },
    weapon: { type: 'spectral', damage: 14, cooldown: 0.55, range: 380, pierce: 1, count: 4 },
    ultimate: { name: 'Spectral Storm', icon: 'üëª', desc: 'Unleashes a rapid-fire spiral of spectral bolts in all directions', color: '#74b9ff',
      activate(p) {
        let shot = 0;
        const interval = setInterval(() => {
          for (let i = 0; i < 8; i++) spawnProjectile((i/8)*Math.PI*2 + shot*0.18, { ...p.weapon, damage: p.weapon.damage*2, pierce:3 });
          shot++;
          if (shot >= 8) clearInterval(interval);
        }, 80);
        triggerSuperFlash('#74b9ff');
      }
    }
  }
];

const UPGRADES_POOL = [
  // Universal
  { id: 'hpup',    name: 'Forest Herb',      icon: 'üåø', desc: '+30 max HP and restore 20 HP',           rarity: 'common', apply: (p) => { p.maxHp += 30; p.hp = Math.min(p.hp + 20, p.maxHp); } },
  { id: 'speedup', name: 'Moonboots',         icon: 'üåô', desc: '+15% movement speed',                    rarity: 'common', apply: (p) => { p.speed *= 1.15; } },
  { id: 'dmgup',   name: 'Dark Fang',         icon: 'ü¶∑', desc: '+25% weapon damage',                     rarity: 'rare',   apply: (p) => { p.weapon.damage *= 1.25; } },
  { id: 'cddown',  name: 'Night Haste',       icon: '‚ö°', desc: '-20% attack cooldown',                   rarity: 'rare',   apply: (p) => { p.weapon.cooldown *= 0.8; } },
  { id: 'rangeup', name: 'Far Sight',         icon: 'üî≠', desc: '+25% attack range',                      rarity: 'rare',   apply: (p) => { p.weapon.range *= 1.25; } },
  { id: 'pierce',  name: 'Shadow Pierce',     icon: 'üó°Ô∏è', desc: 'Attacks pierce one extra enemy',         rarity: 'epic',   apply: (p) => { if(p.weapon.pierce < 99) p.weapon.pierce += 1; } },
  { id: 'count',   name: 'Echoes',            icon: '‚ú®', desc: '+1 projectile per attack',               rarity: 'epic',   apply: (p) => { p.weapon.count = (p.weapon.count||1) + 1; } },
  { id: 'regen',   name: 'Moonblood',         icon: 'ü©∏', desc: 'Regenerate 2 HP every second',           rarity: 'rare',   apply: (p) => { p.regen = (p.regen||0) + 2; } },
  { id: 'magnet',  name: 'XP Magnet',         icon: 'üß≤', desc: '+60% experience gem pickup radius',      rarity: 'common', apply: (p) => { p.pickupRadius *= 1.6; } },
  { id: 'armor',   name: 'Bark Armor',        icon: 'üõ°Ô∏è', desc: 'Reduce all damage taken by 15%',         rarity: 'rare',   apply: (p) => { p.armor = (p.armor||0) + 0.15; } },
];

// ‚îÄ‚îÄ‚îÄ TOWN UPGRADES (persistent, bought with gold) ‚îÄ‚îÄ‚îÄ
const TOWN_UPGRADES = [
  { id:'town_hp',     icon:'‚ù§Ô∏è',  name:'Fortified Den',    desc:'+20 max HP per rank',         cost:30, maxRank:6,
    apply: () => {} /* applied on game start via townUpgrades */ },
  { id:'town_spd',    icon:'üåô',  name:'Night Stride',     desc:'+8% movement speed per rank',  cost:35, maxRank:5,
    apply: () => {} },
  { id:'town_dmg',    icon:'ü¶∑',  name:'Cursed Fangs',     desc:'+12% weapon damage per rank',  cost:40, maxRank:5,
    apply: () => {} },
  { id:'town_armor',  icon:'üõ°Ô∏è',  name:'Bark Plating',     desc:'+6% damage reduction per rank',cost:55, maxRank:4,
    apply: () => {} },
  { id:'town_regen',  icon:'ü©∏',  name:'Dark Sap',         desc:'+1 HP regen/sec per rank',     cost:50, maxRank:4,
    apply: () => {} },
  { id:'town_energy', icon:'‚ö°',  name:'Energy Crystal',   desc:'+15 starting energy per rank', cost:60, maxRank:4,
    apply: () => {} },
  { id:'town_magnet', icon:'üß≤',  name:'Lure Glyph',       desc:'+25% pickup radius per rank',  cost:45, maxRank:3,
    apply: () => {} },
];

// Persistent state (survives runs)
let gold = 0;
let townUpgrades = {}; // { upgradeId: rank }

const ENEMY_TYPES = [
  { name: 'Sunbeam Sprite', emoji: '‚ú®', spriteKey: 'sunsprite',  hp: 18,  speed: 90,  xp: 5,  dmg: 8,  color: '#ffd700', size: 16 },
  { name: 'Happy Honeybee', emoji: 'üêù', spriteKey: 'honeybee',   hp: 12,  speed: 145, xp: 7,  dmg: 6,  color: '#f0c040', size: 14 },
  { name: 'Morning Dew',    emoji: 'üíß', spriteKey: 'dewdrop',    hp: 35,  speed: 60,  xp: 10, dmg: 12, color: '#89d4f5', size: 20 },
  { name: 'Daybloom',       emoji: 'üå∏', spriteKey: 'daybloom',   hp: 55,  speed: 40,  xp: 15, dmg: 15, color: '#ffb7c5', size: 22 },
  { name: 'Gleaming Gem',   emoji: 'üíé', spriteKey: 'gem',        hp: 80,  speed: 75,  xp: 25, dmg: 20, color: '#a0f0ff', size: 24 },
];

const BOSS_TYPES = [
  { name: 'Grand Sunkeeper', emoji: '‚òÄÔ∏è', spriteKey: 'boss_sunkeeper', hp: 500, speed: 55, xp: 150, dmg: 30, color: '#ff9900', size: 45, boss: true },
  { name: 'Queen Blossom',   emoji: 'üå∫', spriteKey: 'boss_blossom',   hp: 400, speed: 65, xp: 120, dmg: 25, color: '#ff69b4', size: 40, boss: true },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SPRITE ASSET SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HOW TO USE CUSTOM SPRITES:
//   1. Place PNG files in the same folder as this HTML (or any accessible URL)
//   2. Replace null values below with file paths, e.g. 'assets/squirrel.png'
//   3. Recommended size: 64√ó64 or 128√ó128 pixels, transparent PNG
//   4. The game auto-falls-back to emoji if a sprite fails to load
//
// SPRITE KEY REFERENCE:
//   Raiders:  'squirrel' | 'beaver' | 'catthulu' | 'cobra' | 'honker'
//   Enemies:  'sunsprite' | 'honeybee' | 'dewdrop' | 'daybloom' | 'gem'
//   Bosses:   'boss_sunkeeper' | 'boss_blossom'
//   Pickups:  'xpgem'

const SPRITE_PATHS = {
  squirrel:     null,   // e.g. 'sprites/squirrel.png'
  beaver:       null,
  catthulu:     null,
  cobra:        null,
  honker:       null,
  sunsprite:    null,
  honeybee:     null,
  dewdrop:      null,
  daybloom:     null,
  gem:          null,
  boss_sunkeeper: null,
  boss_blossom: null,
  xpgem:        null,
};

const SPRITES = {}; // populated by loadSprites()

function loadSprites() {
  Object.entries(SPRITE_PATHS).forEach(([key, path]) => {
    if (!path) return;
    const img = new Image();
    img.onload  = () => { SPRITES[key] = img; console.log('‚úÖ Sprite loaded:', key); };
    img.onerror = () => { console.warn('‚ö†Ô∏è Sprite failed:', key, path); };
    img.src = path;
  });
}

// Draw an entity: uses sprite if available, otherwise falls back to emoji.
// Call inside a ctx.save() / ctx.restore() block with world-space translate already applied.
function drawEntity(emoji, spriteKey, size, alpha = 1, poisoned = false) {
  const sprite = SPRITES[spriteKey];
  const s = size * 2.2;
  ctx.globalAlpha = poisoned ? alpha * 0.55 : alpha;
  if (sprite && sprite.complete && sprite.naturalWidth > 0) {
    ctx.drawImage(sprite, -s / 2, -s / 2, s, s);
    if (poisoned) {
      // Green tint overlay
      ctx.globalCompositeOperation = 'source-atop';
      ctx.fillStyle = 'rgba(46,204,113,0.5)';
      ctx.fillRect(-s / 2, -s / 2, s, s);
      ctx.globalCompositeOperation = 'source-over';
    }
  } else {
    ctx.font = s + 'px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, 0, 0);
  }
  ctx.globalAlpha = 1;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AUDIO ENGINE  (Web Audio API ‚Äî no external files)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let audioCtx = null;
let masterGain = null;
let musicNodes = [];
let musicPlaying = false;
let muted = false;
let bgMusic = null;
let lastShootSfx = 0;   // throttle shoot sounds
let lastXpSfx = 0;      // throttle xp sounds
let lastHurtSfx = 0;    // throttle hurt sounds

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.45;
    masterGain.connect(audioCtx.destination);
  } catch(e) { console.warn('Web Audio not available:', e); }
}

// ‚îÄ‚îÄ SFX ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function playSFX(type) {
  if (!audioCtx || muted) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime;

  const osc = (freq, type_, dur, gainVal, freqEnd) => {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type_;
    o.frequency.setValueAtTime(freq, t);
    if (freqEnd) o.frequency.exponentialRampToValueAtTime(freqEnd, t + dur);
    g.gain.setValueAtTime(gainVal, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    o.connect(g); g.connect(masterGain);
    o.start(t); o.stop(t + dur + 0.01);
  };

  const noise = (dur, gainVal, hpFreq = 0) => {
    const buf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * dur), audioCtx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(gainVal, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    src.connect(g);
    if (hpFreq > 0) {
      const f = audioCtx.createBiquadFilter();
      f.type = 'bandpass'; f.frequency.value = hpFreq;
      g.connect(f); f.connect(masterGain);
    } else {
      g.connect(masterGain);
    }
    src.start(t);
  };

  switch (type) {
    case 'shoot_laser':    osc(900, 'square',   0.08, 0.12, 450); break;
    case 'shoot_bite':     osc(320, 'sawtooth', 0.07, 0.18, 180); break;
    case 'shoot_tentacle': osc(260, 'square',   0.09, 0.14, 130); break;
    case 'shoot_poison':   osc(700, 'sine',     0.05, 0.08, 1100); break;
    case 'shoot_spectral': osc(500, 'triangle', 0.10, 0.10, 800); break;

    case 'hit':
      noise(0.06, 0.28, 1100);
      break;

    case 'enemy_die':
      osc(380, 'sawtooth', 0.18, 0.22, 70);
      noise(0.12, 0.15, 600);
      break;

    case 'player_hurt':
      osc(180, 'square', 0.22, 0.38, 90);
      noise(0.15, 0.20, 200);
      break;

    case 'levelup':
      [523, 659, 784, 1047].forEach((f, i) => {
        const start = t + i * 0.08;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle'; o.frequency.value = f;
        g.gain.setValueAtTime(0.28, start);
        g.gain.exponentialRampToValueAtTime(0.001, start + 0.22);
        o.connect(g); g.connect(masterGain);
        o.start(start); o.stop(start + 0.25);
      });
      break;

    case 'xp':
      osc(1300, 'sine', 0.05, 0.06, 1700);
      break;

    case 'boss':
      [110, 146, 196].forEach((f, i) => {
        const start = t + i * 0.18;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.value = f;
        g.gain.setValueAtTime(0.38, start);
        g.gain.exponentialRampToValueAtTime(0.001, start + 0.5);
        o.connect(g); g.connect(masterGain);
        o.start(start); o.stop(start + 0.55);
      });
      break;

    case 'gameover':
      [392, 330, 294, 220].forEach((f, i) => {
        const start = t + i * 0.22;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle'; o.frequency.value = f;
        g.gain.setValueAtTime(0.35, start);
        g.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
        o.connect(g); g.connect(masterGain);
        o.start(start); o.stop(start + 0.45);
      });
      break;

    case 'supermove':
      // Big ascending sweep + impact
      osc(200, 'sawtooth', 0.05, 0.4, 900);
      osc(400, 'square',   0.10, 0.3, 1200);
      [1, 2, 3, 4, 5].forEach(i => {
        const start2 = t + i * 0.04;
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = 'triangle'; o2.frequency.value = 300 * i;
        g2.gain.setValueAtTime(0.15, start2);
        g2.gain.exponentialRampToValueAtTime(0.001, start2 + 0.25);
        o2.connect(g2); g2.connect(masterGain);
        o2.start(start2); o2.stop(start2 + 0.28);
      });
      break;
  }
}

// ‚îÄ‚îÄ PROCEDURAL MUSIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Dark minor-pentatonic chiptune. Three layers: bass, melody, percussion.
const _N = { // note frequencies
  C2:65.4, Eb2:77.8, G2:98.0, Bb2:116.5,
  C3:130.8, Eb3:155.6, G3:196.0, Bb3:233.1, C4:261.6,
  D4:293.7, Eb4:311.1, G4:392.0, Bb4:466.2, C5:523.3,
};
const BASS = ['C2','C2','G2','C2','Bb2','Bb2','G2','Bb2','Eb2','Eb2','Bb2','Eb2','G2','G2','Eb2','G2'];
const MELO = [
  'C4', null, 'Eb4', null, 'G4', 'Eb4', null, 'C4',
  'Bb3', null, 'G3',  null, 'Bb3','G3',  null, 'Eb3',
  'G4',  null, null,  'C4', 'Eb4',null,  'G3', null,
  'C4', 'D4', 'Eb4',  null, 'C4', null,  null,  null,
];
const PAD  = ['C3','Eb3','G3','Bb3','C3','Eb3','G3','Bb3'];
const STEP_SEC = 0.145;
let _seqStep = 0, _nextNote = 0, _schedTimer = null;

function startMusic() {
  if (bgMusic) return;
  bgMusic = new Audio('music.mp3'); // ‚Üê change filename here if needed
  bgMusic.loop = true;
  bgMusic.volume = muted ? 0 : 0.4;
  bgMusic.play().catch(() => {}); // silently handle autoplay block
}

function stopMusic() {
  if (!bgMusic) return;
  bgMusic.pause();
  bgMusic.currentTime = 0;
  bgMusic = null;
}

function _scheduleMusic() {
  if (!musicPlaying || !audioCtx) return;
  while (_nextNote < audioCtx.currentTime + 0.25) {
    _playMusicStep(_seqStep, _nextNote);
    _seqStep = (_seqStep + 1) % 32;
    _nextNote += STEP_SEC;
  }
  _schedTimer = setTimeout(_scheduleMusic, 60);
}

function _playMusicStep(step, time) {
  if (muted) return;
  const bassNote = BASS[step % BASS.length];
  const meloNote = MELO[step % MELO.length];
  const padNote  = PAD[step  % PAD.length];

  if (bassNote) _musOsc(_N[bassNote], 'square',   time, STEP_SEC * 0.85, 0.10);
  if (meloNote) _musOsc(_N[meloNote], 'triangle', time, STEP_SEC * 0.55, 0.07);
  // Pad ‚Äî long held note every 8 steps
  if (step % 8 === 0 && padNote) _musOsc(_N[padNote], 'sine', time, STEP_SEC * 6, 0.04);
  // Kick (low thud) on beats 0, 8, 16, 24
  if (step % 8 === 0) _musKick(time);
  // Snare on step 4, 12, 20, 28
  if (step % 8 === 4) _musSnare(time);
  // Hi-hat every 2 steps
  if (step % 2 === 0) _musHihat(time);
}

function _musOsc(freq, type_, time, dur, gainVal) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type_; o.frequency.value = freq;
  g.gain.setValueAtTime(gainVal, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + dur);
  o.connect(g); g.connect(masterGain);
  o.start(time); o.stop(time + dur + 0.01);
  musicNodes.push(o);
}

function _musKick(time) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(160, time);
  o.frequency.exponentialRampToValueAtTime(40, time + 0.08);
  g.gain.setValueAtTime(0.5, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
  o.connect(g); g.connect(masterGain);
  o.start(time); o.stop(time + 0.14);
  musicNodes.push(o);
}

function _musSnare(time) {
  const buf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * 0.09), audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
  const src = audioCtx.createBufferSource(); src.buffer = buf;
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 1800;
  g.gain.setValueAtTime(0.18, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + 0.09);
  src.connect(f); f.connect(g); g.connect(masterGain);
  src.start(time);
  musicNodes.push(src);
}

function _musHihat(time) {
  const buf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * 0.04), audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
  const src = audioCtx.createBufferSource(); src.buffer = buf;
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 6000;
  g.gain.setValueAtTime(0.07, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
  src.connect(f); f.connect(g); g.connect(masterGain);
  src.start(time);
  musicNodes.push(src);
}

function setMute(isMuted) {
  muted = isMuted;
  if (masterGain) masterGain.gain.value = muted ? 0 : 0.45;
  if (bgMusic) bgMusic.volume = muted ? 0 : 0.4;
  document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let canvas, ctx;
let state = 'select'; // select | playing | levelup | paused | town | gameover
let prevState = 'playing'; // state before town/pause
let selectedChar = null;
let player, enemies, projectiles, xpGems, energyOrbs, goldCoins, floatTexts, particles;
let camera = { x: 0, y: 0 };
let keys = {}, justPressed = {};
let kills = 0, elapsed = 0, gameStartTime = 0;
let lastFrame = 0, lastSpawn = 0, spawnInterval = 2.0;
let lastBossTime = 0;
let xpToNext = 20;
let totalXP = 0, runGold = 0;
let pendingUpgrades = false;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CHARACTER SELECT UI
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildCharSelect() {
  const grid = document.getElementById('charGrid');
  grid.innerHTML = '';
  CHARS.forEach(c => {
    const card = document.createElement('div');
    card.className = 'char-card';
    card.style.setProperty('--color', c.color);
    card.style.setProperty('--glow', c.glow);
    card.style.setProperty('--shadow', c.shadow);
    card.innerHTML = `
      <span class="char-emoji">${c.emoji}</span>
      <div class="char-name">${c.name}</div>
      <div class="char-desc">${c.desc}</div>
      <div style="margin-top:0.5em;font-size:0.65rem;color:#6b7280;background:rgba(255,255,255,0.04);border-radius:8px;padding:4px 6px;line-height:1.4">
        ${c.ultimate.icon} <span style="color:#fde68a;font-weight:700">${c.ultimate.name}</span><br>
        <span style="color:#4b5563">${c.ultimate.desc}</span>
      </div>
      <div class="char-stat"><span>HP</span><span>SPD</span><span>DMG</span></div>
      <div class="stat-bar"><div class="stat-fill" style="width:${c.stats.hp}%;background:${c.color}"></div></div>
      <div class="stat-bar"><div class="stat-fill" style="width:${c.stats.spd}%;background:${c.color}"></div></div>
      <div class="stat-bar"><div class="stat-fill" style="width:${c.stats.dmg}%;background:${c.color}"></div></div>
    `;
    card.onclick = () => {
      document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected'));
      card.classList.add('selected');
      selectedChar = c;
      document.getElementById('startBtn').disabled = false;
    };
    grid.appendChild(card);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAME INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function startGame() {
  const c = selectedChar;

  // Build town bonus stats
  const tb = {
    hp:     (townUpgrades['town_hp']    || 0) * 20,
    spd:    1 + (townUpgrades['town_spd']   || 0) * 0.08,
    dmg:    1 + (townUpgrades['town_dmg']   || 0) * 0.12,
    armor:  (townUpgrades['town_armor'] || 0) * 0.06,
    regen:  (townUpgrades['town_regen'] || 0) * 1,
    energy: (townUpgrades['town_energy']|| 0) * 15,
    magnet: 1 + (townUpgrades['town_magnet']|| 0) * 0.25,
  };

  player = {
    x: 0, y: 0,
    hp: c.hp + tb.hp, maxHp: c.hp + tb.hp,
    speed: c.speed * tb.spd,
    emoji: c.emoji, color: c.color,
    weapon: { ...c.weapon, damage: c.weapon.damage * tb.dmg },
    attackTimer: 0,
    xp: 0, level: 1,
    invTime: 0,
    regen: tb.regen, regenTimer: 0,
    pickupRadius: 80 * tb.magnet,
    armor: tb.armor,
    size: 20,
    energy: tb.energy, maxEnergy: 100,
    superReady: tb.energy >= 100,
    superCD: 0,
  };
  enemies = []; projectiles = []; xpGems = []; energyOrbs = []; goldCoins = [];
  floatTexts = []; particles = [];
  kills = 0; elapsed = 0; lastSpawn = 0; spawnInterval = 2.0; lastBossTime = 0;
  xpToNext = 20; totalXP = 0; runGold = 0;
  keys = {}; justPressed = {};
  camera = { x: 0, y: 0 };
  gameStartTime = performance.now();
  lastFrame = performance.now();
  lastShootSfx = 0; lastXpSfx = 0; lastHurtSfx = 0;

  initAudio();
  loadSprites();
  stopMusic();
  startMusic();

  showScreen('hud');
  state = 'playing';
  requestAnimationFrame(gameLoop);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SCREEN MANAGEMENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showScreen(id) {
  ['selectScreen','hud','levelupScreen','pauseScreen','townScreen','gameoverScreen'].forEach(s => {
    document.getElementById(s).classList.add('hidden');
  });
  if (id) document.getElementById(id).classList.remove('hidden');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAME LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function gameLoop(ts) {
  if (state === 'gameover') return;
  const dt = Math.min((ts - lastFrame) / 1000, 0.05);
  lastFrame = ts;

  if (state === 'playing') {
    elapsed = (ts - gameStartTime) / 1000;
    update(dt);
  }
  justPressed = {};
  render();
  requestAnimationFrame(gameLoop);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UPDATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function update(dt) {
  handleSupermoveInput();
  movePlayer(dt);
  updateProjectiles(dt);
  updateEnemies(dt);
  updateXPGems(dt);
  updateEnergyOrbs(dt);
  updateGoldCoins(dt);
  updateParticles(dt);
  spawnEnemies(dt);
  attackLogic(dt);
  regenLogic(dt);
  updateHUD();
}

function movePlayer(dt) {
  let dx = 0, dy = 0;
  if (keys['ArrowLeft']  || keys['a']) dx -= 1;
  if (keys['ArrowRight'] || keys['d']) dx += 1;
  if (keys['ArrowUp']    || keys['w']) dy -= 1;
  if (keys['ArrowDown']  || keys['s']) dy += 1;
  const len = Math.sqrt(dx*dx + dy*dy);
  if (len > 0) { dx /= len; dy /= len; }
  player.x += dx * player.speed * dt;
  player.y += dy * player.speed * dt;
  camera.x = player.x - canvas.width / 2;
  camera.y = player.y - canvas.height / 2;
  if (player.invTime > 0) player.invTime -= dt;
}

function handleSupermoveInput() {
  if (!justPressed[' ']) return;
  if (player.energy < player.maxEnergy) return;
  if (player.superCD > 0) return;
  player.energy = 0;
  player.superReady = false;
  player.superCD = 0.5; // brief lockout
  playSFX('supermove');
  selectedChar.ultimate.activate(player);
  spawnFloatText(player.x, player.y - 70, '‚ú® ' + selectedChar.ultimate.name + '!', selectedChar.ultimate.color);
}

function triggerSuperFlash(color) {
  const el = document.getElementById('superFlash');
  el.style.background = color;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 180);
}

// ‚îÄ‚îÄ ENERGY ORBS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateEnergyOrbs(dt) {
  for (let i = energyOrbs.length - 1; i >= 0; i--) {
    const o = energyOrbs[i];
    const d = dist(player, o);
    if (d < player.pickupRadius) {
      const dx = player.x - o.x, dy = player.y - o.y;
      o.x += (dx/d) * 280 * dt;
      o.y += (dy/d) * 280 * dt;
    }
    if (dist(player, o) < 18) {
      player.energy = Math.min(player.maxEnergy, player.energy + o.value);
      energyOrbs.splice(i, 1);
      if (player.energy >= player.maxEnergy) {
        player.superReady = true;
        player.energy = player.maxEnergy;
      }
    }
  }
}

// ‚îÄ‚îÄ GOLD COINS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateGoldCoins(dt) {
  for (let i = goldCoins.length - 1; i >= 0; i--) {
    const c = goldCoins[i];
    const d = dist(player, c);
    if (d < player.pickupRadius + 20) {
      const dx = player.x - c.x, dy = player.y - c.y;
      c.x += (dx/d) * 260 * dt;
      c.y += (dy/d) * 260 * dt;
    }
    if (dist(player, c) < 18) {
      gold += c.value;
      runGold += c.value;
      goldCoins.splice(i, 1);
      document.getElementById('goldCounter').textContent = 'ü™ô ' + gold;
    }
  }
}

function regenLogic(dt) {
  if (player.regen <= 0) return;
  player.regenTimer += dt;
  if (player.regenTimer >= 1) {
    player.regenTimer -= 1;
    player.hp = Math.min(player.hp + player.regen, player.maxHp);
  }
}

function attackLogic(dt) {
  player.attackTimer -= dt;
  if (player.attackTimer > 0) return;
  player.attackTimer = player.weapon.cooldown;
  fireWeapon();
}

function fireWeapon() {
  const w = player.weapon;
  const target = getNearestEnemy(w.range);
  const count = w.count || 1;

  if (w.type === 'tentacle') {
    // Fire in all directions, no target needed
    for (let i = 0; i < count; i++) {
      spawnProjectile((i / count) * Math.PI * 2, w);
    }
  } else if (w.type === 'spectral') {
    // Fire evenly spread in all directions
    for (let i = 0; i < count; i++) {
      spawnProjectile((i / count) * Math.PI * 2, w);
    }
  } else if (w.type === 'poison') {
    if (!target) return;
    const baseAngle = Math.atan2(target.y - player.y, target.x - player.x);
    const spread = w.spread || 0.3;
    for (let i = 0; i < count; i++) {
      spawnProjectile(baseAngle + (i - (count-1)/2) * spread, w);
    }
  } else {
    // laser, bite ‚Äî aim at nearest enemy
    if (!target && w.type !== 'laser') return;
    const angle = target
      ? Math.atan2(target.y - player.y, target.x - player.x)
      : -Math.PI / 2;
    for (let i = 0; i < count; i++) {
      const spread = (count > 1) ? (i - (count-1)/2) * 0.15 : 0;
      spawnProjectile(angle + spread, w);
    }
  }
}

function spawnProjectile(angle, w) {
  const speed = w.type === 'tentacle' ? 280 : w.type === 'bite' ? 220 :
                w.type === 'poison' ? 320 : 350;
  // Throttled shoot SFX (max once per 80ms to avoid audio spam)
  const now = performance.now();
  if (now - lastShootSfx > 80) {
    lastShootSfx = now;
    playSFX('shoot_' + w.type);
  }
  projectiles.push({
    x: player.x, y: player.y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    damage: w.damage,
    pierce: w.pierce || 1,
    pierceLeft: w.pierce || 1,
    range: w.range,
    distTravelled: 0,
    type: w.type,
    lifesteal: w.lifesteal || 0,
    hit: new Set(),
    // Visual
    size: w.type === 'laser' ? 5 : w.type === 'tentacle' ? 8 :
          w.type === 'bite' ? 10 : w.type === 'poison' ? 6 : 7,
    color: w.type === 'laser' ? '#ff9f43' :
           w.type === 'bite' ? '#ef4444' :
           w.type === 'tentacle' ? '#9b59b6' :
           w.type === 'poison' ? '#2ecc71' : '#74b9ff',
  });
}

function getNearestEnemy(range) {
  let nearest = null, nearDist = Infinity;
  for (const e of enemies) {
    const d = dist(player, e);
    if (d < range && d < nearDist) { nearest = e; nearDist = d; }
  }
  return nearest;
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.distTravelled += Math.sqrt(p.vx*p.vx + p.vy*p.vy) * dt;

    // Check enemy collisions
    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (p.hit.has(j)) continue;
      if (dist(p, e) < e.size + p.size) {
        p.hit.add(j);
        p.pierceLeft--;
        damageEnemy(e, j, p.damage, p.lifesteal);
        spawnHitParticles(e.x, e.y, p.color);
        if (p.type === 'poison') e.poisoned = (e.poisoned || 0) + 3;
        if (p.pierceLeft <= 0) { projectiles.splice(i, 1); break; }
      }
    }
    if (i < projectiles.length && p.distTravelled > p.range) {
      projectiles.splice(i, 1);
    }
  }
}

function damageEnemy(e, idx, dmg, lifesteal) {
  e.hp -= dmg;
  playSFX('hit');
  if (lifesteal > 0) {
    player.hp = Math.min(player.hp + dmg * lifesteal, player.maxHp);
    spawnFloatText(player.x, player.y - 30, '+' + Math.floor(dmg * lifesteal), '#2ecc71');
  }
  spawnFloatText(e.x, e.y - 20, '-' + Math.floor(dmg), '#fff');
  if (e.hp <= 0) {
    kills++;
    playSFX('enemy_die');
    // Drop XP gems
    const gemCount = e.boss ? 8 : 1;
    for (let g = 0; g < gemCount; g++) {
      xpGems.push({
        x: e.x + (Math.random()-0.5)*30,
        y: e.y + (Math.random()-0.5)*30,
        value: Math.floor(e.xp / gemCount),
      });
    }
    // Drop energy orb (40% chance, 80% for boss)
    if (Math.random() < (e.boss ? 0.8 : 0.4)) {
      energyOrbs.push({
        x: e.x + (Math.random()-0.5)*20,
        y: e.y + (Math.random()-0.5)*20,
        value: e.boss ? 30 : 10 + Math.floor(Math.random() * 8),
      });
    }
    // Drop gold (50% for normal, 100% for boss)
    if (Math.random() < (e.boss ? 1.0 : 0.5)) {
      const gVal = e.boss
        ? 10 + Math.floor(Math.random()*15)
        : 1 + Math.floor(Math.random() * (e.size > 18 ? 4 : 2));
      goldCoins.push({
        x: e.x + (Math.random()-0.5)*20,
        y: e.y + (Math.random()-0.5)*20,
        value: gVal,
      });
    }
    spawnDeathParticles(e.x, e.y, e.color);
    enemies.splice(idx, 1);
  }
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    // Move toward player
    const dx = player.x - e.x, dy = player.y - e.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d > 0) {
      e.x += (dx/d) * e.speed * dt;
      e.y += (dy/d) * e.speed * dt;
    }
    // Poison tick
    if (e.poisoned > 0) {
      e.poisoned -= dt;
      e.poisonTick = (e.poisonTick || 0) + dt;
      if (e.poisonTick >= 0.5) {
        e.poisonTick = 0;
        e.hp -= 5;
        if (e.hp <= 0) {
          kills++;
          xpGems.push({ x: e.x, y: e.y, value: e.xp });
          if (Math.random() < 0.4) energyOrbs.push({ x: e.x, y: e.y, value: 10 });
          if (Math.random() < 0.5) goldCoins.push({ x: e.x, y: e.y, value: 1 + Math.floor(Math.random()*3) });
          spawnDeathParticles(e.x, e.y, e.color);
          enemies.splice(i, 1); continue;
        }
      }
    }
    // Damage player
    if (player.invTime <= 0 && d < e.size + player.size) {
      const dmgTaken = Math.max(1, Math.floor(e.dmg * (1 - player.armor)));
      player.hp -= dmgTaken;
      player.invTime = 0.6;
      spawnFloatText(player.x, player.y - 40, '-' + dmgTaken, '#ef4444');
      screenShake(0.3);
      const nowHurt = performance.now();
      if (nowHurt - lastHurtSfx > 300) { lastHurtSfx = nowHurt; playSFX('player_hurt'); }
      if (player.hp <= 0) { endGame(); return; }
    }
  }
}

function updateXPGems(dt) {
  for (let i = xpGems.length - 1; i >= 0; i--) {
    const g = xpGems[i];
    const d = dist(player, g);
    if (d < player.pickupRadius) {
      // Move toward player
      const dx = player.x - g.x, dy = player.y - g.y;
      g.x += (dx/d) * 300 * dt;
      g.y += (dy/d) * 300 * dt;
    }
    if (dist(player, g) < 18) {
      player.xp += g.value;
      totalXP += g.value;
      xpGems.splice(i, 1);
      const nowXp = performance.now();
      if (nowXp - lastXpSfx > 60) { lastXpSfx = nowXp; playSFX('xp'); }
      checkLevelUp();
    }
  }
}

function checkLevelUp() {
  while (player.xp >= xpToNext) {
    player.xp -= xpToNext;
    player.level++;
    xpToNext = Math.floor(xpToNext * 1.25 + 10);
    triggerLevelUp();
    break;
  }
}

function triggerLevelUp() {
  playSFX('levelup');
  state = 'levelup';
  showLevelUpScreen();
}

function showLevelUpScreen() {
  const container = document.getElementById('upgradeCards');
  container.innerHTML = '';
  // Pick 3 random upgrades
  const pool = [...UPGRADES_POOL].sort(() => Math.random() - 0.5).slice(0, 3);
  pool.forEach(u => {
    const card = document.createElement('div');
    card.className = 'upgrade-card';
    card.innerHTML = `
      <div class="upgrade-icon">${u.icon}</div>
      <div class="upgrade-name">${u.name}</div>
      <div class="upgrade-desc">${u.desc}</div>
      <span class="upgrade-rarity rarity-${u.rarity}">${u.rarity}</span>
    `;
    card.onclick = () => {
      u.apply(player);
      document.getElementById('levelupScreen').classList.add('hidden');
      document.getElementById('hud').classList.remove('hidden');
      state = 'playing';
      lastFrame = performance.now(); // prevent dt spike
      spawnFloatText(player.x, player.y - 50, u.name + '!', '#c084fc');
    };
    container.appendChild(card);
  });
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('levelupScreen').classList.remove('hidden');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SPAWNING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let shakeTime = 0, shakeMag = 0;
function screenShake(dur) { shakeTime = dur; shakeMag = 6; }

function spawnEnemies(dt) {
  lastSpawn += dt;
  // Scale difficulty
  spawnInterval = Math.max(0.4, 2.0 - elapsed * 0.015);
  const danger = Math.floor(elapsed / 30); // increases every 30s

  if (lastSpawn < spawnInterval) return;
  lastSpawn = 0;

  const count = 1 + Math.floor(danger * 0.5) + Math.floor(Math.random() * 2);
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r = 500 + Math.random() * 200;
    const typeIdx = Math.min(Math.floor(Math.random() * (1 + danger)), ENEMY_TYPES.length - 1);
    const t = ENEMY_TYPES[typeIdx];
    const scale = 1 + danger * 0.1;
    enemies.push({
      x: player.x + Math.cos(angle) * r,
      y: player.y + Math.sin(angle) * r,
      hp: t.hp * scale, maxHp: t.hp * scale,
      speed: t.speed, xp: t.xp, dmg: t.dmg,
      emoji: t.emoji, spriteKey: t.spriteKey,
      color: t.color, size: t.size, boss: false,
    });
  }

  // Boss at 60s intervals
  if (elapsed > 30 && elapsed - lastBossTime >= 60) {
    lastBossTime = elapsed;
    const angle = Math.random() * Math.PI * 2;
    const b = BOSS_TYPES[Math.floor(Math.random() * BOSS_TYPES.length)];
    const bossScale = 1 + Math.floor(elapsed / 60) * 0.3;
    enemies.push({
      x: player.x + Math.cos(angle) * 600,
      y: player.y + Math.sin(angle) * 600,
      hp: b.hp * bossScale, maxHp: b.hp * bossScale,
      speed: b.speed, xp: b.xp, dmg: b.dmg,
      emoji: b.emoji, spriteKey: b.spriteKey,
      color: b.color, size: b.size, boss: true,
    });
    spawnFloatText(player.x, player.y - 80, '‚ö† BOSS INCOMING!', '#ff9900');
    playSFX('boss');
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PARTICLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function spawnHitParticles(x, y, color) {
  for (let i = 0; i < 4; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 50 + Math.random() * 80;
    particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 0.4, color, size: 3 });
  }
}
function spawnDeathParticles(x, y, color) {
  for (let i = 0; i < 10; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 80 + Math.random() * 120;
    particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 0.7, color, size: 4 + Math.random()*3 });
  }
}
function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.vx *= 0.9; p.vy *= 0.9;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function spawnFloatText(x, y, text, color) {
  floatTexts.push({ x, y, text, color, life: 1.0 });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HUD UPDATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateHUD() {
  const hpPct = Math.max(0, player.hp / player.maxHp * 100);
  document.getElementById('hpFill').style.width = hpPct + '%';
  document.getElementById('hpText').textContent = Math.max(0, Math.floor(player.hp)) + '/' + Math.floor(player.maxHp);
  const xpPct = player.xp / xpToNext * 100;
  document.getElementById('xpFill').style.width = xpPct + '%';
  document.getElementById('levelBadge').textContent = 'Level ' + player.level;
  document.getElementById('killCounter').textContent = 'üíÄ ' + kills;
  const mins = Math.floor(elapsed / 60).toString().padStart(2,'0');
  const secs = Math.floor(elapsed % 60).toString().padStart(2,'0');
  document.getElementById('timerBox').textContent = mins + ':' + secs;
  // Energy
  const ePct = (player.energy / player.maxEnergy) * 100;
  const fill = document.getElementById('energyFill');
  fill.style.width = ePct + '%';
  fill.className = 'energy-fill' + (player.superReady ? ' charged' : '');
  document.getElementById('energyText').textContent = Math.floor(player.energy) + '/100';
  const hint = document.getElementById('superHint');
  hint.textContent = '‚ö° SPACE ‚Äî ' + (selectedChar ? selectedChar.ultimate.name : 'SUPERMOVE') + '!';
  hint.className = 'super-hint' + (player.superReady ? ' visible' : '');
  // Supermove cooldown
  if (player.superCD > 0) player.superCD -= 1/60;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RENDER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const TREE_POSITIONS = [];
for (let i = 0; i < 300; i++) {
  TREE_POSITIONS.push({ x: (Math.random()-0.5)*4000, y: (Math.random()-0.5)*4000, scale: 0.7 + Math.random()*0.6 });
}
const STARS = [];
for (let i = 0; i < 150; i++) {
  STARS.push({ x: Math.random()*2000, y: Math.random()*1200, size: 1 + Math.random()*2 });
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // Screen shake
  let sx = 0, sy = 0;
  if (shakeTime > 0) {
    shakeTime -= 1/60;
    sx = (Math.random()-0.5) * shakeMag;
    sy = (Math.random()-0.5) * shakeMag;
  }

  ctx.save();
  ctx.translate(sx, sy);

  // Background
  const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W*0.8);
  grad.addColorStop(0, '#0f1020');
  grad.addColorStop(1, '#060810');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars (fixed to screen, parallax feel)
  ctx.save();
  const starOffX = camera.x * 0.02 % 2000;
  const starOffY = camera.y * 0.02 % 1200;
  STARS.forEach(s => {
    const sx2 = ((s.x - starOffX) % W + W) % W;
    const sy2 = ((s.y - starOffY) % H + H) % H;
    ctx.fillStyle = `rgba(255,255,255,${0.2 + Math.random()*0.1})`;
    ctx.beginPath();
    ctx.arc(sx2, sy2, s.size * 0.5, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.restore();

  // World transform
  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  // Ground tiles
  const tileSize = 80;
  const startX = Math.floor(camera.x / tileSize) * tileSize;
  const startY = Math.floor(camera.y / tileSize) * tileSize;
  for (let tx = startX; tx < camera.x + W + tileSize; tx += tileSize) {
    for (let ty = startY; ty < camera.y + H + tileSize; ty += tileSize) {
      const shade = ((Math.floor(tx/tileSize) + Math.floor(ty/tileSize)) % 2 === 0) ? '0a0f18' : '0c1220';
      ctx.fillStyle = '#' + shade;
      ctx.fillRect(tx, ty, tileSize, tileSize);
    }
  }

  // Trees (decorative)
  TREE_POSITIONS.forEach(t => {
    const screenX = t.x - camera.x;
    const screenY = t.y - camera.y;
    if (screenX < -60 || screenX > W+60 || screenY < -60 || screenY > H+60) return;
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.font = '32px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.globalAlpha = 0.5;
    ctx.fillText('üå≤', 0, 0);
    ctx.restore();
  });

  // XP Gems
  ctx.font = '12px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  xpGems.forEach(g => {
    ctx.fillStyle = '#a855f7';
    ctx.shadowColor = '#c084fc';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(g.x, g.y, 5, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.shadowBlur = 0;

  // Energy Orbs (cyan diamond shape)
  energyOrbs.forEach(o => {
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = '#06b6d4';
    ctx.shadowColor = '#a5f3fc';
    ctx.shadowBlur = 10;
    const s = 5;
    ctx.fillRect(-s, -s, s*2, s*2);
    ctx.shadowBlur = 0;
    ctx.restore();
  });

  // Gold Coins (spinning star effect)
  goldCoins.forEach(c => {
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.fillStyle = '#fbbf24';
    ctx.shadowColor = '#fde68a';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(0, 0, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#fde68a';
    ctx.beginPath();
    ctx.arc(0, 0, 2.5, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Enemies
  enemies.forEach(e => {
    const isInv = e.poisoned > 0;
    ctx.save();
    ctx.translate(e.x, e.y);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(0, e.size*0.6, e.size*0.7, e.size*0.25, 0, 0, Math.PI*2);
    ctx.fill();

    // HP bar for bosses
    if (e.boss) {
      const bw = e.size * 3;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(-bw/2, -e.size - 12, bw, 6);
      ctx.fillStyle = '#ff9900';
      ctx.fillRect(-bw/2, -e.size - 12, bw * (e.hp / e.maxHp), 6);
    }

    // Flash green if poisoned
    if (isInv) ctx.globalAlpha = 0.6;
    drawEntity(e.emoji, e.spriteKey || e.emoji, e.size, 1, isInv);

    ctx.globalAlpha = 1;
    ctx.restore();

    // HP bar (small, non-boss)
    if (!e.boss && e.hp < e.maxHp) {
      const bw = e.size * 2;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(e.x - bw/2, e.y - e.size - 8, bw, 4);
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(e.x - bw/2, e.y - e.size - 8, bw * (e.hp / e.maxHp), 4);
    }
  });

  // Projectiles
  projectiles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 12;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  });

  // Player
  ctx.save();
  ctx.translate(player.x, player.y);

  // Player shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, player.size*0.65, player.size*0.7, player.size*0.25, 0, 0, Math.PI*2);
  ctx.fill();

  // Aura
  if (player.invTime > 0) {
    ctx.globalAlpha = 0.4 + Math.sin(elapsed*20)*0.3;
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(0, 0, player.size * 1.5, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 20;
  drawEntity(player.emoji, selectedChar ? selectedChar.id : player.emoji, player.size);
  ctx.shadowBlur = 0;
  ctx.restore();

  ctx.restore(); // world transform

  // Float texts (screen space)
  const now = performance.now();
  for (let i = floatTexts.length - 1; i >= 0; i--) {
    const ft = floatTexts[i];
    ft.life -= 1/60;
    if (ft.life <= 0) { floatTexts.splice(i, 1); continue; }
    const sx2 = ft.x - camera.x + sx;
    const sy2 = ft.y - camera.y - (1 - ft.life) * 50 + sy;
    ctx.globalAlpha = ft.life;
    ctx.fillStyle = ft.color;
    ctx.font = 'bold 14px Nunito, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(ft.text, sx2, sy2);
  }
  ctx.globalAlpha = 1;

  ctx.restore(); // shake
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAME OVER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function endGame() {
  state = 'gameover';
  stopMusic();
  playSFX('gameover');
  const mins = Math.floor(elapsed / 60).toString().padStart(2,'0');
  const secs = Math.floor(elapsed % 60).toString().padStart(2,'0');
  document.getElementById('gameoverStats').innerHTML = `
    Survived <span>${mins}:${secs}</span><br>
    Enemies defeated <span>${kills}</span><br>
    Level reached <span>${player.level}</span><br>
    Total XP collected <span>${totalXP}</span><br>
    Gold earned this run <span>ü™ô ${runGold}</span><br>
    Total gold saved <span>ü™ô ${gold}</span><br>
    Raider <span>${selectedChar.emoji} ${selectedChar.name}</span>
  `;
  showScreen('gameoverScreen');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PAUSE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function togglePause() {
  if (state === 'playing') {
    state = 'paused';
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('pauseScreen').classList.remove('hidden');
  } else if (state === 'paused') {
    resumeGame();
  }
}

function resumeGame() {
  state = 'playing';
  lastFrame = performance.now();
  gameStartTime += performance.now() - lastFrame; // prevent time warp
  document.getElementById('pauseScreen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TOWN
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function openTown(fromState) {
  prevState = fromState;
  buildTownScreen();
  showScreen('townScreen');
  state = 'town';
}

function leaveTown() {
  if (prevState === 'playing' || prevState === 'paused') {
    state = 'playing';
    lastFrame = performance.now();
    showScreen('hud');
  } else {
    // came from gameover / menu
    state = 'select';
    buildCharSelect();
    showScreen('selectScreen');
  }
}

function buildTownScreen() {
  document.getElementById('townGoldDisplay').textContent = 'ü™ô ' + gold + ' gold';
  const grid = document.getElementById('townGrid');
  grid.innerHTML = '';
  TOWN_UPGRADES.forEach(u => {
    const rank = townUpgrades[u.id] || 0;
    const maxed = rank >= u.maxRank;
    const cost = u.cost + rank * Math.floor(u.cost * 0.5);
    const canAfford = gold >= cost;
    const card = document.createElement('div');
    card.className = 'town-card' + (maxed ? ' maxed' : (!canAfford ? ' cant-afford' : ''));
    card.innerHTML = `
      <div class="town-level">${rank}/${u.maxRank}</div>
      <div class="town-icon">${u.icon}</div>
      <div class="town-name">${u.name}</div>
      <div class="town-desc">${u.desc}</div>
      ${maxed
        ? '<div class="town-maxed-label">‚úì Maxed Out</div>'
        : `<div class="town-cost">${canAfford ? 'ü™ô' : 'üîí'} ${cost} gold</div>`
      }
    `;
    if (!maxed && canAfford) {
      card.onclick = () => {
        gold -= cost;
        townUpgrades[u.id] = rank + 1;
        playSFX('levelup');
        buildTownScreen();
      };
    }
    grid.appendChild(card);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UTILS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INPUT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.addEventListener('keydown', e => {
  if (!keys[e.key]) justPressed[e.key] = true;
  keys[e.key] = true;
  if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'ArrowDown') e.preventDefault();
  // Pause toggle
  if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
    if (state === 'playing' || state === 'paused') togglePause();
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BOOT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
window.addEventListener('load', () => {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');

  // Touch / mobile movement
  let touchId = null, touchStartX = 0, touchStartY = 0;
  canvas.addEventListener('touchstart', e => {
    const t = e.changedTouches[0];
    touchId = t.identifier; touchStartX = t.clientX; touchStartY = t.clientY;
  }, {passive: true});
  canvas.addEventListener('touchmove', e => {
    for (const t of e.changedTouches) {
      if (t.identifier !== touchId) continue;
      const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
      const threshold = 10;
      keys['a'] = dx < -threshold; keys['d'] = dx > threshold;
      keys['w'] = dy < -threshold; keys['s'] = dy > threshold;
    }
  }, {passive: true});
  canvas.addEventListener('touchend', () => {
    keys['a'] = keys['d'] = keys['w'] = keys['s'] = false;
  }, {passive: true});

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  buildCharSelect();
  showScreen('selectScreen');

  // Mute
  document.getElementById('muteBtn').onclick = () => setMute(!muted);

  // Start / Retry
  document.getElementById('startBtn').onclick = () => {
    initAudio(); showScreen(null); startGame();
  };
  document.getElementById('retryBtn').onclick = () => {
    showScreen(null); startGame();
  };

  // Gameover ‚Üí Town
  document.getElementById('visitTownBtn').onclick = () => {
    initAudio(); openTown('gameover');
  };

  // Gameover ‚Üí Main Menu
  document.getElementById('menuBtn').onclick = () => {
    stopMusic(); state = 'select'; buildCharSelect();
    showScreen('selectScreen');
    document.getElementById('startBtn').disabled = true;
    selectedChar = null;
    document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected'));
  };

  // Pause screen buttons
  document.getElementById('pauseResume').onclick = () => resumeGame();
  document.getElementById('pauseTown').onclick   = () => { initAudio(); openTown('paused'); };
  document.getElementById('pauseRetry').onclick  = () => { showScreen(null); startGame(); };
  document.getElementById('pauseMenu').onclick   = () => {
    stopMusic(); state = 'select'; buildCharSelect();
    showScreen('selectScreen');
    document.getElementById('startBtn').disabled = !selectedChar;
  };

  // Town leave
  document.getElementById('townLeaveBtn').onclick = () => leaveTown();
});
</script>
</body>
</html>
