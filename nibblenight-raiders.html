<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NibbleNight Raiders</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a14;
    font-family: 'Nunito', sans-serif;
    overflow: hidden;
    color: #fff;
    width: 100vw;
    height: 100vh;
  }

  canvas { display: block; position: absolute; top: 0; left: 0; }

  /* â”€â”€ SCREENS â”€â”€ */
  .screen {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 10;
  }
  .screen.hidden { display: none; }

  /* â”€â”€ CHARACTER SELECT â”€â”€ */
  #selectScreen {
    background: radial-gradient(ellipse at 50% 30%, #1a1030 0%, #0a0a14 70%);
  }
  .game-title {
    font-family: 'Fredoka One', cursive;
    font-size: clamp(2.5rem, 6vw, 5rem);
    color: #c9a0ff;
    text-shadow: 0 0 40px #8b5cf680, 0 0 80px #8b5cf640;
    letter-spacing: 2px;
    margin-bottom: 0.3em;
    animation: glow 3s ease-in-out infinite alternate;
  }
  @keyframes glow {
    from { text-shadow: 0 0 30px #8b5cf660, 0 0 60px #8b5cf630; }
    to   { text-shadow: 0 0 60px #c9a0ffaa, 0 0 120px #8b5cf660; }
  }
  .subtitle {
    color: #9ca3af; font-size: 1rem; font-weight: 600;
    letter-spacing: 3px; text-transform: uppercase;
    margin-bottom: 2.5em;
  }
  .select-label {
    color: #e2c8ff; font-size: 1.1rem; font-weight: 700;
    margin-bottom: 1.2em; letter-spacing: 1px;
  }
  .character-grid {
    display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;
    max-width: 900px; padding: 0 1rem;
  }
  .char-card {
    background: rgba(255,255,255,0.04);
    border: 2px solid rgba(255,255,255,0.08);
    border-radius: 20px;
    padding: 1.5rem 1.2rem;
    width: 155px; cursor: pointer;
    transition: all 0.25s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .char-card::before {
    content: '';
    position: absolute; inset: 0;
    background: var(--glow);
    opacity: 0;
    transition: opacity 0.3s;
    border-radius: 18px;
  }
  .char-card:hover::before, .char-card.selected::before { opacity: 0.12; }
  .char-card:hover, .char-card.selected {
    border-color: var(--color);
    transform: translateY(-4px);
    box-shadow: 0 12px 30px rgba(0,0,0,0.4), 0 0 20px var(--shadow);
  }
  .char-card.selected { transform: translateY(-6px) scale(1.04); }
  .char-emoji { font-size: 3rem; margin-bottom: 0.4em; display: block; }
  .char-name {
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; color: var(--color);
    margin-bottom: 0.4em;
  }
  .char-desc { font-size: 0.72rem; color: #9ca3af; line-height: 1.4; }
  .char-stat {
    margin-top: 0.7em;
    font-size: 0.68rem; color: #6b7280;
    display: flex; justify-content: space-between;
  }
  .stat-bar {
    height: 3px; background: rgba(255,255,255,0.08);
    border-radius: 2px; margin-top: 0.5em; overflow: hidden;
  }
  .stat-fill { height: 100%; border-radius: 2px; background: var(--color); }

  .start-btn {
    margin-top: 2rem;
    font-family: 'Fredoka One', cursive;
    font-size: 1.4rem;
    padding: 0.8em 3em;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg, #8b5cf6, #c084fc);
    color: white;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 8px 25px rgba(139,92,246,0.4);
    letter-spacing: 1px;
  }
  .start-btn:hover { transform: scale(1.06); box-shadow: 0 12px 35px rgba(139,92,246,0.6); }
  .start-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

  /* â”€â”€ HUD â”€â”€ */
  #hud {
    position: absolute; inset: 0; pointer-events: none; z-index: 5;
  }
  .hud-top {
    position: absolute; top: 1rem; left: 50%;
    transform: translateX(-50%);
    display: flex; align-items: center; gap: 1.5rem;
  }
  .hp-bar-wrap {
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 20px; padding: 4px 10px;
    display: flex; align-items: center; gap: 8px;
    min-width: 200px;
  }
  .hp-icon { font-size: 1rem; }
  .hp-track {
    flex: 1; height: 10px;
    background: rgba(255,255,255,0.1);
    border-radius: 5px; overflow: hidden;
  }
  .hp-fill {
    height: 100%; border-radius: 5px;
    background: linear-gradient(90deg, #ef4444, #f87171);
    transition: width 0.2s;
  }
  .hp-text { font-size: 0.75rem; font-weight: 700; white-space: nowrap; }

  .timer-box {
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 20px; padding: 4px 16px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.3rem; color: #c9a0ff;
  }

  .xp-bar-wrap {
    position: absolute; bottom: 0; left: 0; right: 0;
    height: 6px; background: rgba(0,0,0,0.4);
  }
  .xp-fill {
    height: 100%;
    background: linear-gradient(90deg, #a855f7, #ec4899);
    transition: width 0.3s ease;
  }

  .level-badge {
    position: absolute; bottom: 1rem; left: 50%;
    transform: translateX(-50%);
    font-family: 'Fredoka One', cursive;
    font-size: 0.9rem; color: #c9a0ff;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(139,92,246,0.4);
    border-radius: 20px; padding: 3px 14px;
  }

  .kill-counter {
    position: absolute; top: 1rem; right: 1rem;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px; padding: 5px 12px;
    font-size: 0.85rem; font-weight: 700;
    color: #fbbf24;
  }

  .mute-btn {
    position: absolute; top: 1rem; left: 1rem;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px; padding: 5px 10px;
    font-size: 1rem; cursor: pointer;
    pointer-events: all;
    transition: all 0.15s;
    color: white; line-height: 1;
  }
  .mute-btn:hover { background: rgba(255,255,255,0.1); }

  /* â”€â”€ LEVEL UP â”€â”€ */
  #levelupScreen {
    background: rgba(5, 3, 15, 0.88);
    backdrop-filter: blur(8px);
  }
  .levelup-title {
    font-family: 'Fredoka One', cursive;
    font-size: 2.5rem; color: #c9a0ff;
    text-shadow: 0 0 30px #8b5cf6;
    margin-bottom: 0.3em;
    animation: pulse 1s ease-in-out infinite;
  }
  @keyframes pulse {
    0%,100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  .levelup-sub { color: #9ca3af; margin-bottom: 2em; font-size: 1rem; }
  .upgrade-cards {
    display: flex; gap: 1.2rem; flex-wrap: wrap; justify-content: center;
    max-width: 800px;
  }
  .upgrade-card {
    background: rgba(255,255,255,0.04);
    border: 2px solid rgba(139,92,246,0.3);
    border-radius: 18px; padding: 1.5rem 1.2rem;
    width: 210px; cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    pointer-events: all;
  }
  .upgrade-card:hover {
    border-color: #8b5cf6;
    background: rgba(139,92,246,0.12);
    transform: translateY(-4px);
    box-shadow: 0 10px 30px rgba(139,92,246,0.3);
  }
  .upgrade-icon { font-size: 2.5rem; margin-bottom: 0.5em; }
  .upgrade-name {
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; color: #e9d5ff; margin-bottom: 0.4em;
  }
  .upgrade-desc { font-size: 0.8rem; color: #9ca3af; line-height: 1.5; }
  .upgrade-rarity {
    font-size: 0.65rem; font-weight: 700; letter-spacing: 2px;
    text-transform: uppercase; margin-top: 0.6em;
    padding: 2px 8px; border-radius: 10px; display: inline-block;
  }
  .rarity-common { background: rgba(156,163,175,0.2); color: #9ca3af; }
  .rarity-rare { background: rgba(59,130,246,0.2); color: #60a5fa; }
  .rarity-epic { background: rgba(139,92,246,0.2); color: #c084fc; }

  /* â”€â”€ GAME OVER â”€â”€ */
  #gameoverScreen {
    background: rgba(5, 3, 15, 0.93);
    backdrop-filter: blur(12px);
    text-align: center; gap: 1rem;
  }
  .gameover-title {
    font-family: 'Fredoka One', cursive;
    font-size: 4rem; color: #ef4444;
    text-shadow: 0 0 40px #ef444460;
    margin-bottom: 0.1em;
  }
  .gameover-stats {
    color: #9ca3af; font-size: 1rem;
    line-height: 2.2;
  }
  .gameover-stats span { color: #e9d5ff; font-weight: 700; }
  .retry-btn {
    margin-top: 1.5rem;
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem; padding: 0.7em 2.5em;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg, #ef4444, #f97316);
    color: white; cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 6px 20px rgba(239,68,68,0.4);
  }
  .retry-btn:hover { transform: scale(1.06); }

  /* â”€â”€ ENERGY / SUPERMOVE HUD â”€â”€ */
  .hud-bottom-left {
    position: absolute; bottom: 1.8rem; left: 1rem;
    display: flex; flex-direction: column; gap: 6px; align-items: flex-start;
  }
  .energy-wrap {
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 20px; padding: 4px 10px;
    display: flex; align-items: center; gap: 8px;
    min-width: 160px;
  }
  .energy-track {
    flex: 1; height: 8px;
    background: rgba(255,255,255,0.08);
    border-radius: 4px; overflow: hidden;
  }
  .energy-fill {
    height: 100%; border-radius: 4px;
    background: linear-gradient(90deg, #06b6d4, #a5f3fc);
    transition: width 0.15s ease;
  }
  .energy-fill.charged {
    background: linear-gradient(90deg, #facc15, #fde68a);
    box-shadow: 0 0 8px #facc1580;
    animation: energyPulse 0.6s ease-in-out infinite alternate;
  }
  @keyframes energyPulse {
    from { box-shadow: 0 0 4px #facc1560; }
    to   { box-shadow: 0 0 18px #facc15cc; }
  }
  .super-hint {
    font-size: 0.65rem; font-weight: 800; letter-spacing: 1px;
    color: #fde68a; text-transform: uppercase; white-space: nowrap;
    opacity: 0; transition: opacity 0.3s;
  }
  .super-hint.visible { opacity: 1; animation: hintBounce 0.8s ease-in-out infinite alternate; }
  @keyframes hintBounce {
    from { transform: scale(1); } to { transform: scale(1.08); }
  }
  .super-active-flash {
    position: absolute; inset: 0;
    pointer-events: none; z-index: 4;
    opacity: 0; transition: opacity 0.08s;
  }
  .super-active-flash.show { opacity: 1; }

  /* â”€â”€ GOLD COUNTER â”€â”€ */
  .gold-counter {
    position: absolute; top: 1rem; right: 8rem;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(255,215,0,0.25);
    border-radius: 12px; padding: 5px 12px;
    font-size: 0.85rem; font-weight: 700;
    color: #fbbf24;
  }

  /* â”€â”€ PAUSE SCREEN â”€â”€ */
  #pauseScreen {
    background: rgba(5,3,15,0.82);
    backdrop-filter: blur(14px);
    gap: 1rem;
    text-align: center;
  }
  .pause-title {
    font-family: 'Fredoka One', cursive;
    font-size: 3rem; color: #c9a0ff;
    text-shadow: 0 0 30px #8b5cf6;
    margin-bottom: 0.5rem;
  }
  .pause-subtitle { color: #6b7280; font-size: 0.85rem; letter-spacing: 2px; margin-bottom: 1.5rem; }
  .pause-btn {
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; padding: 0.65em 2.5em;
    border: none; border-radius: 50px; cursor: pointer;
    transition: all 0.18s; width: 220px; display: block;
    margin: 0 auto 0.5rem;
  }
  .pause-btn:hover { transform: scale(1.05); }
  .pause-btn-resume  { background: linear-gradient(135deg,#8b5cf6,#c084fc); color:#fff; box-shadow:0 5px 18px rgba(139,92,246,0.4); }
  .pause-btn-town    { background: linear-gradient(135deg,#d97706,#fbbf24); color:#fff; box-shadow:0 5px 18px rgba(251,191,36,0.35); }
  .pause-btn-retry   { background: linear-gradient(135deg,#16a34a,#4ade80); color:#fff; box-shadow:0 5px 18px rgba(74,222,128,0.35); }
  .pause-btn-menu    { background: rgba(255,255,255,0.06); color:#9ca3af; border:1px solid rgba(255,255,255,0.1); }
  .pause-controls {
    margin-top: 1rem; color: #4b5563; font-size: 0.72rem;
    line-height: 2; letter-spacing: 0.5px;
  }
  .pause-controls kbd {
    background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12);
    border-radius: 4px; padding: 1px 6px; font-size: 0.7rem; color: #9ca3af;
  }

  /* â”€â”€ TOWN SCREEN â”€â”€ */
  #townScreen {
    background: radial-gradient(ellipse at 50% 20%, #1a1200 0%, #0a0a00 60%, #0a0a14 100%);
    gap: 0; overflow-y: auto; padding: 2rem 1rem;
    justify-content: flex-start;
  }
  .town-title {
    font-family: 'Fredoka One', cursive;
    font-size: clamp(2rem,5vw,3.5rem); color: #fbbf24;
    text-shadow: 0 0 30px #d9770660;
    margin-bottom: 0.2rem;
  }
  .town-sub { color: #78716c; font-size: 0.9rem; letter-spacing: 2px; margin-bottom: 0.4rem; }
  .town-gold {
    font-family: 'Fredoka One', cursive;
    font-size: 1.4rem; color: #fbbf24;
    background: rgba(251,191,36,0.08);
    border: 1px solid rgba(251,191,36,0.2);
    border-radius: 20px; padding: 6px 20px;
    margin-bottom: 1.5rem;
  }
  .town-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
    gap: 0.9rem; max-width: 900px; width: 100%;
    margin-bottom: 1.5rem;
  }
  .town-card {
    background: rgba(255,255,255,0.03);
    border: 2px solid rgba(251,191,36,0.15);
    border-radius: 16px; padding: 1.1rem 1rem;
    text-align: center; transition: all 0.2s;
    position: relative;
  }
  .town-card:not(.maxed):not(.cant-afford) { cursor: pointer; }
  .town-card:not(.maxed):not(.cant-afford):hover {
    border-color: #fbbf24;
    background: rgba(251,191,36,0.07);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  }
  .town-card.cant-afford { opacity: 0.45; }
  .town-card.maxed { border-color: rgba(74,222,128,0.3); opacity: 0.7; }
  .town-icon { font-size: 2rem; margin-bottom: 0.4rem; }
  .town-name { font-family: 'Fredoka One', cursive; font-size: 1rem; color: #fde68a; margin-bottom: 0.3rem; }
  .town-desc { font-size: 0.72rem; color: #78716c; line-height: 1.4; margin-bottom: 0.5rem; }
  .town-cost { font-size: 0.8rem; font-weight: 700; color: #fbbf24; }
  .town-level {
    position: absolute; top: 8px; right: 10px;
    font-size: 0.65rem; font-weight: 800; color: #6b7280;
    letter-spacing: 1px;
  }
  .town-maxed-label { font-size: 0.72rem; color: #4ade80; font-weight: 700; margin-top: 0.2rem; }
  .town-leave-btn {
    font-family: 'Fredoka One', cursive;
    font-size: 1.2rem; padding: 0.7em 3em;
    border: none; border-radius: 50px;
    background: linear-gradient(135deg,#8b5cf6,#c084fc);
    color: white; cursor: pointer;
    box-shadow: 0 6px 20px rgba(139,92,246,0.4);
    transition: all 0.2s; margin-top: 0.5rem;
  }
  .town-leave-btn:hover { transform: scale(1.05); }

  /* â”€â”€ TITLE SCREEN â”€â”€ */
  #titleScreen {
    background: #000;
    z-index: 20;
    gap: 0;
    transition: opacity 0.8s ease;
  }
  #titleScreen.fade-out { opacity: 0; pointer-events: none; }
  #titleCanvas { position: absolute; inset: 0; width: 100%; height: 100%; }
  .title-content {
    position: relative; z-index: 2;
    display: flex; flex-direction: column;
    align-items: center; gap: 0;
    animation: titleEntrance 1.2s cubic-bezier(0.16,1,0.3,1) both;
  }
  @keyframes titleEntrance {
    from { opacity: 0; transform: translateY(30px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .title-logo {
    font-family: 'Fredoka One', cursive;
    font-size: clamp(3rem, 9vw, 7rem);
    line-height: 1;
    color: #fff;
    text-shadow:
      0 0 40px #8b5cf6,
      0 0 80px #8b5cf660,
      0 0 160px #8b5cf630,
      0 4px 0 rgba(0,0,0,0.5);
    letter-spacing: 3px;
    animation: titleGlow 3s ease-in-out infinite alternate;
  }
  @keyframes titleGlow {
    from { text-shadow: 0 0 30px #8b5cf6, 0 0 60px #8b5cf650, 0 4px 0 rgba(0,0,0,0.5); }
    to   { text-shadow: 0 0 60px #c9a0ff, 0 0 120px #8b5cf680, 0 0 200px #8b5cf630, 0 4px 0 rgba(0,0,0,0.5); }
  }
  .title-subtitle-line {
    font-size: clamp(0.7rem, 1.5vw, 1rem);
    color: #6b7280; letter-spacing: 5px;
    text-transform: uppercase; margin-top: 0.4em; margin-bottom: 2rem;
    font-weight: 600;
  }
  .title-press {
    font-family: 'Fredoka One', cursive;
    font-size: clamp(1rem, 2.5vw, 1.4rem);
    color: #c9a0ff;
    animation: pressAnim 1.8s ease-in-out infinite;
    letter-spacing: 2px;
  }
  @keyframes pressAnim {
    0%,100% { opacity: 0.5; transform: scale(1); }
    50%      { opacity: 1;   transform: scale(1.04); }
  }
  .title-save-badge {
    margin-top: 2rem;
    font-size: 0.75rem; color: #4b5563;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.07);
    border-radius: 20px; padding: 5px 14px;
    display: flex; gap: 8px; align-items: center;
  }
  .title-save-badge span { color: #fbbf24; font-weight: 700; }
  .title-version { position: absolute; bottom: 1rem; right: 1.5rem; font-size: 0.65rem; color: #374151; }

  /* â”€â”€ BOSS HP OVERLAY â”€â”€ */
  #bossHPBar {
    position: absolute; bottom: 2.5rem; left: 50%;
    transform: translateX(-50%);
    width: min(500px, 80vw);
    background: rgba(0,0,0,0.75);
    border: 1px solid rgba(255,153,0,0.4);
    border-radius: 14px; padding: 8px 14px;
    display: none; pointer-events: none;
    animation: bossBarIn 0.4s ease-out;
  }
  @keyframes bossBarIn {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to   { opacity: 1; transform: translateX(-50%) translateY(0); }
  }
  .boss-name {
    font-family: 'Fredoka One', cursive;
    font-size: 0.85rem; color: #ff9900;
    margin-bottom: 5px; text-align: center;
    text-shadow: 0 0 12px #ff990060;
  }
  .boss-track {
    height: 12px; background: rgba(255,255,255,0.08);
    border-radius: 6px; overflow: hidden;
  }
  .boss-fill {
    height: 100%; border-radius: 6px;
    background: linear-gradient(90deg, #ef4444, #ff9900, #fbbf24);
    transition: width 0.25s ease;
  }

  /* â”€â”€ WAVE BADGE â”€â”€ */
  .wave-badge {
    position: absolute; top: 1rem; left: 50%;
    transform: translateX(-50%) translateY(-60px);
    font-family: 'Fredoka One', cursive;
    font-size: 1.1rem; color: #fff;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 20px; padding: 4px 16px;
    pointer-events: none;
    transition: transform 0.4s cubic-bezier(0.16,1,0.3,1), opacity 0.4s;
    opacity: 0;
  }
  .wave-badge.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }

  /* â”€â”€ STREAK COUNTER â”€â”€ */
  .streak-display {
    position: absolute; top: 4.5rem; right: 1rem;
    font-family: 'Fredoka One', cursive;
    font-size: 0.85rem; color: #f97316;
    background: rgba(0,0,0,0.6);
    border: 1px solid rgba(249,115,22,0.25);
    border-radius: 12px; padding: 4px 10px;
    opacity: 0; transition: opacity 0.3s;
    pointer-events: none;
  }
  .streak-display.show { opacity: 1; }

  /* â”€â”€ SAVE NOTIFICATION â”€â”€ */
  .save-toast {
    position: fixed; bottom: 2rem; left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: rgba(0,0,0,0.85);
    border: 1px solid rgba(74,222,128,0.3);
    border-radius: 30px; padding: 8px 20px;
    font-size: 0.8rem; color: #4ade80;
    font-weight: 700; letter-spacing: 1px;
    opacity: 0; pointer-events: none;
    z-index: 100;
    transition: all 0.3s ease;
  }
  .save-toast.show {
    opacity: 1; transform: translateX(-50%) translateY(0);
  }

  /* â”€â”€ SCREEN TRANSITIONS â”€â”€ */
  .screen { transition: opacity 0.15s ease; }

  /* â”€â”€ UPGRADED CHAR CARD â”€â”€ */
  .char-card { width: 165px; }
  .char-portrait {
    width: 72px; height: 72px;
    margin: 0 auto 0.5em;
    border-radius: 50%;
    background: rgba(255,255,255,0.06);
    border: 2px solid rgba(255,255,255,0.1);
    overflow: hidden; display: flex;
    align-items: center; justify-content: center;
    position: relative;
    transition: border-color 0.3s;
  }
  .char-card.selected .char-portrait,
  .char-card:hover .char-portrait { border-color: var(--color); }
  .char-portrait img {
    width: 100%; height: 100%; object-fit: contain;
  }
  .char-portrait-emoji { font-size: 2.8rem; line-height: 1; }
  .char-unlocked { font-size: 0.6rem; color: #4ade80; font-weight: 800;
    letter-spacing: 1px; text-transform: uppercase; margin-bottom: 0.15em; }

  /* â”€â”€ IMPROVED LEVEL-UP â”€â”€ */
  .levelup-current {
    font-size: 0.85rem; color: #6b7280; margin-bottom: 1.5em;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 20px; padding: 4px 16px;
  }

  /* â”€â”€ IMPROVED GAMEOVER â”€â”€ */
  .gameover-best { font-size: 0.8rem; color: #fbbf24; margin-top: 0.5rem; }
  .gameover-divider {
    width: 200px; height: 1px;
    background: rgba(255,255,255,0.08); margin: 1rem auto;
  }
    position: absolute; pointer-events: none;
    font-weight: 800; font-size: 0.85rem; z-index: 6;
    animation: floatUp 1s ease-out forwards;
  }
  @keyframes floatUp {
    from { opacity: 1; transform: translateY(0); }
    to   { opacity: 0; transform: translateY(-60px); }
  }
</style>
</head>
<body>

<!-- TITLE SCREEN -->
<div class="screen" id="titleScreen">
  <canvas id="titleCanvas"></canvas>
  <div class="title-content" id="titleContent">
    <div class="title-logo" id="titleLogoText" style="display:none">NibbleNight<br>Raiders</div>
    <div class="title-subtitle-line" id="titleSubLine" style="display:none">Roguelite Â· Autobattler Â· Survive the Light</div>
    <div class="title-press">â€” Press SPACE to begin â€”</div>
    <div style="margin-top:0.8rem;font-size:0.8rem;color:#4b5563;letter-spacing:2px">Press <span style="color:#8b5cf6;font-weight:800">M</span> to toggle music</div>
    <div class="title-save-badge" id="titleSaveBadge" style="display:none">
      ğŸ’¾ Save found &nbsp;|&nbsp; ğŸª™ <span id="titleSaveGold">0</span> gold &nbsp;|&nbsp; ğŸ† Best: <span id="titleBestTime">--:--</span>
    </div>
  </div>
  <div class="title-version">v0.1 Â· NibbleNight Raiders</div>
</div>

<!-- CHARACTER SELECT -->
<div class="screen hidden" id="selectScreen">
  <h1 class="game-title">NibbleNight Raiders</h1>
  <p class="subtitle">Roguelite Â· Autobattler Â· Survive the Light</p>
  <p class="select-label">Choose your Raider</p>
  <div class="character-grid" id="charGrid"></div>
  <button class="start-btn" id="startBtn" disabled>Enter the Forest</button>
</div>

<!-- GAME CANVAS -->
<canvas id="gameCanvas"></canvas>

<!-- SUPERMOVE FLASH -->
<div id="superFlash" class="super-active-flash"></div>

<!-- BOSS HP BAR -->
<div id="bossHPBar">
  <div class="boss-name" id="bossName">Grand Sunkeeper</div>
  <div class="boss-track"><div class="boss-fill" id="bossFill" style="width:100%"></div></div>
</div>

<!-- HUD -->
<div class="screen hidden" id="hud">
  <div class="hud-top">
    <div class="hp-bar-wrap">
      <span class="hp-icon">â¤ï¸</span>
      <div class="hp-track"><div class="hp-fill" id="hpFill" style="width:100%"></div></div>
      <span class="hp-text" id="hpText">100/100</span>
    </div>
    <div class="timer-box" id="timerBox">00:00</div>
  </div>
  <div class="wave-badge" id="waveBadge">Wave 1</div>
  <div class="gold-counter" id="goldCounter">ğŸª™ 0</div>
  <div class="kill-counter" id="killCounter">ğŸ’€ 0</div>
  <div class="streak-display" id="streakDisplay">ğŸ”¥ x0</div>
  <button class="mute-btn" id="muteBtn" title="Toggle sound">ğŸ”Š</button>
  <div class="hud-bottom-left">
    <div class="energy-wrap">
      <span style="font-size:0.9rem">âš¡</span>
      <div class="energy-track"><div class="energy-fill" id="energyFill" style="width:0%"></div></div>
      <span style="font-size:0.7rem;font-weight:700;color:#9ca3af;white-space:nowrap" id="energyText">0/100</span>
    </div>
    <span class="super-hint" id="superHint">SPACE â€” SUPERMOVE!</span>
  </div>
  <div class="xp-bar-wrap">
    <div class="xp-fill" id="xpFill" style="width:0%"></div>
  </div>
  <div class="level-badge" id="levelBadge">Level 1</div>
</div>

<!-- LEVEL UP -->
<div class="screen hidden" id="levelupScreen">
  <div class="levelup-title">â¬† Level Up!</div>
  <div class="levelup-sub">Choose an upgrade</div>
  <div class="levelup-current" id="levelupCurrent">Level 1 â†’ 2</div>
  <div class="upgrade-cards" id="upgradeCards"></div>
</div>

<!-- PAUSE SCREEN -->
<div class="screen hidden" id="pauseScreen">
  <div class="pause-title">â¸ Paused</div>
  <div class="pause-subtitle">GAME PAUSED</div>
  <button class="pause-btn pause-btn-resume"  id="pauseResume">â–¶ Resume</button>
  <button class="pause-btn pause-btn-town"    id="pauseTown">ğŸ˜ Visit Town</button>
  <button class="pause-btn pause-btn-retry"   id="pauseRetry">â†º Restart Run</button>
  <button class="pause-btn pause-btn-menu"    id="pauseMenu">â† Main Menu</button>
  <div class="pause-controls">
    <kbd>WASD</kbd> / <kbd>â†‘â†“â†â†’</kbd> Move &nbsp;|&nbsp;
    <kbd>SPACE</kbd> Supermove &nbsp;|&nbsp;
    <kbd>ESC</kbd> Pause
  </div>
</div>

<!-- TOWN SCREEN -->
<div class="screen hidden" id="townScreen">
  <div class="town-title">ğŸ˜ Nibble Town</div>
  <div class="town-sub">Spend your gold on permanent upgrades</div>
  <div class="town-gold" id="townGoldDisplay">ğŸª™ 0 gold</div>
  <div class="town-grid" id="townGrid"></div>
  <button class="town-leave-btn" id="townLeaveBtn">Return to Battle â†’</button>
</div>

<!-- GAME OVER -->
<div class="screen hidden" id="gameoverScreen">
  <div class="gameover-title">ğŸ’€ Defeated!</div>
  <div class="gameover-stats" id="gameoverStats"></div>
  <div class="gameover-best" id="gameoverBest"></div>
  <div class="gameover-divider"></div>
  <button class="retry-btn" id="retryBtn">Try Again</button>
  <button class="retry-btn" id="visitTownBtn" style="background:linear-gradient(135deg,#d97706,#fbbf24);margin-top:0.5rem;box-shadow:0 6px 20px rgba(251,191,36,0.4)">ğŸ˜ Visit Town</button>
  <button class="retry-btn" id="menuBtn" style="background:linear-gradient(135deg,#8b5cf6,#c084fc);margin-top:0.5rem;box-shadow:0 6px 20px rgba(139,92,246,0.4)">Main Menu</button>
</div>

<!-- SAVE TOAST -->
<div class="save-toast" id="saveToast">ğŸ’¾ Progress saved</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CHARS = [
  {
    id: 'squirrel', name: 'Laser Squirrel', emoji: 'ğŸ¿ï¸',
    desc: 'Fires piercing laser beams at enemies',
    color: '#ff9f43', glow: 'rgba(255,159,67,0.3)', shadow: 'rgba(255,159,67,0.5)',
    hp: 100, speed: 210,
    stats: { hp: 60, spd: 80, dmg: 70 },
    weapon: { type: 'laser', damage: 18, cooldown: 0.9, range: 420, pierce: 3, count: 1 },
    ultimate: { name: 'Solar Overcharge', icon: 'â˜€ï¸', desc: 'Fires 24 lasers in all directions', color: '#ff9f43',
      activate(p) {
        for (let i = 0; i < 24; i++) spawnProjectile((i/24)*Math.PI*2, { ...p.weapon, damage: p.weapon.damage*2.5, pierce:99, range: p.weapon.range*1.5 });
        triggerSuperFlash('#ff9f43');
      }
    }
  },
  {
    id: 'beaver', name: 'Vampire Beaver', emoji: 'ğŸ¦«',
    desc: 'Bites enemies and steals their life force',
    color: '#c0392b', glow: 'rgba(192,57,43,0.3)', shadow: 'rgba(192,57,43,0.5)',
    hp: 160, speed: 160,
    stats: { hp: 90, spd: 40, dmg: 60 },
    weapon: { type: 'bite', damage: 30, cooldown: 1.1, range: 110, pierce: 1, lifesteal: 0.35 },
    ultimate: { name: 'Blood Frenzy', icon: 'ğŸ©¸', desc: 'Heal 60 HP + deal massive damage in melee range', color: '#ef4444',
      activate(p) {
        player.hp = Math.min(player.maxHp, player.hp + 60);
        spawnFloatText(player.x, player.y - 50, '+60 HP', '#2ecc71');
        for (let i = 0; i < 16; i++) spawnProjectile((i/16)*Math.PI*2, { ...p.weapon, damage: p.weapon.damage*4, pierce:99, range:160 });
        triggerSuperFlash('#ef4444');
      }
    }
  },
  {
    id: 'catthulu', name: 'Cat-thulu', emoji: 'ğŸ±',
    desc: 'Erupts tentacles in all directions',
    color: '#9b59b6', glow: 'rgba(155,89,182,0.3)', shadow: 'rgba(155,89,182,0.5)',
    hp: 120, speed: 175,
    stats: { hp: 70, spd: 55, dmg: 85 },
    weapon: { type: 'tentacle', damage: 22, cooldown: 1.4, range: 190, pierce: 99, count: 8, aoe: true },
    ultimate: { name: 'Void Eruption', icon: 'ğŸŒ€', desc: 'Massive expanding ring of tentacles wipes all nearby enemies', color: '#9b59b6',
      activate(p) {
        for (let w = 0; w < 3; w++) {
          setTimeout(() => {
            for (let i = 0; i < 20; i++) spawnProjectile((i/20)*Math.PI*2 + w*0.1, { ...p.weapon, damage: p.weapon.damage*3, pierce:99, range: (180+w*120) });
          }, w * 120);
        }
        triggerSuperFlash('#9b59b6');
      }
    }
  },
  {
    id: 'cobra', name: 'Chupa-Cobra', emoji: 'ğŸ',
    desc: 'Sprays rapid poison in a cone',
    color: '#27ae60', glow: 'rgba(39,174,96,0.3)', shadow: 'rgba(39,174,96,0.5)',
    hp: 90, speed: 230,
    stats: { hp: 45, spd: 95, dmg: 65 },
    weapon: { type: 'poison', damage: 7, cooldown: 0.35, range: 240, pierce: 2, count: 3, spread: 0.4 },
    ultimate: { name: 'Venom Nova', icon: 'â˜ ï¸', desc: 'Sprays 32 poison shots in all directions, poisoning every enemy on screen', color: '#27ae60',
      activate(p) {
        for (let i = 0; i < 32; i++) spawnProjectile((i/32)*Math.PI*2, { ...p.weapon, damage: p.weapon.damage*2, pierce:99, range: 800 });
        enemies.forEach(e => { e.poisoned = (e.poisoned||0) + 6; });
        triggerSuperFlash('#27ae60');
      }
    }
  },
  {
    id: 'honker', name: 'Honkergeist', emoji: 'ğŸª¿',
    desc: 'Launches spectral projectiles in 4 directions',
    color: '#74b9ff', glow: 'rgba(116,185,255,0.3)', shadow: 'rgba(116,185,255,0.5)',
    hp: 100, speed: 195,
    stats: { hp: 60, spd: 65, dmg: 75 },
    weapon: { type: 'spectral', damage: 14, cooldown: 0.55, range: 380, pierce: 1, count: 4 },
    ultimate: { name: 'Spectral Storm', icon: 'ğŸ‘»', desc: 'Unleashes a rapid-fire spiral of spectral bolts in all directions', color: '#74b9ff',
      activate(p) {
        let shot = 0;
        const interval = setInterval(() => {
          for (let i = 0; i < 8; i++) spawnProjectile((i/8)*Math.PI*2 + shot*0.18, { ...p.weapon, damage: p.weapon.damage*2, pierce:3 });
          shot++;
          if (shot >= 8) clearInterval(interval);
        }, 80);
        triggerSuperFlash('#74b9ff');
      }
    }
  }
];

const UPGRADES_POOL = [
  // Universal
  { id: 'hpup',    name: 'Forest Herb',      icon: 'ğŸŒ¿', desc: '+30 max HP and restore 20 HP',           rarity: 'common', apply: (p) => { p.maxHp += 30; p.hp = Math.min(p.hp + 20, p.maxHp); } },
  { id: 'speedup', name: 'Moonboots',         icon: 'ğŸŒ™', desc: '+15% movement speed',                    rarity: 'common', apply: (p) => { p.speed *= 1.15; } },
  { id: 'dmgup',   name: 'Dark Fang',         icon: 'ğŸ¦·', desc: '+25% weapon damage',                     rarity: 'rare',   apply: (p) => { p.weapon.damage *= 1.25; } },
  { id: 'cddown',  name: 'Night Haste',       icon: 'âš¡', desc: '-20% attack cooldown',                   rarity: 'rare',   apply: (p) => { p.weapon.cooldown *= 0.8; } },
  { id: 'rangeup', name: 'Far Sight',         icon: 'ğŸ”­', desc: '+25% attack range',                      rarity: 'rare',   apply: (p) => { p.weapon.range *= 1.25; } },
  { id: 'pierce',  name: 'Shadow Pierce',     icon: 'ğŸ—¡ï¸', desc: 'Attacks pierce one extra enemy',         rarity: 'epic',   apply: (p) => { if(p.weapon.pierce < 99) p.weapon.pierce += 1; } },
  { id: 'count',   name: 'Echoes',            icon: 'âœ¨', desc: '+1 projectile per attack',               rarity: 'epic',   apply: (p) => { p.weapon.count = (p.weapon.count||1) + 1; } },
  { id: 'regen',   name: 'Moonblood',         icon: 'ğŸ©¸', desc: 'Regenerate 2 HP every second',           rarity: 'rare',   apply: (p) => { p.regen = (p.regen||0) + 2; } },
  { id: 'magnet',  name: 'XP Magnet',         icon: 'ğŸ§²', desc: '+60% experience gem pickup radius',      rarity: 'common', apply: (p) => { p.pickupRadius *= 1.6; } },
  { id: 'armor',   name: 'Bark Armor',        icon: 'ğŸ›¡ï¸', desc: 'Reduce all damage taken by 15%',         rarity: 'rare',   apply: (p) => { p.armor = (p.armor||0) + 0.15; } },
];

// â”€â”€â”€ TOWN UPGRADES (persistent, bought with gold) â”€â”€â”€
const TOWN_UPGRADES = [
  { id:'town_hp',     icon:'â¤ï¸',  name:'Fortified Den',    desc:'+20 max HP per rank',         cost:30, maxRank:6,
    apply: () => {} /* applied on game start via townUpgrades */ },
  { id:'town_spd',    icon:'ğŸŒ™',  name:'Night Stride',     desc:'+8% movement speed per rank',  cost:35, maxRank:5,
    apply: () => {} },
  { id:'town_dmg',    icon:'ğŸ¦·',  name:'Cursed Fangs',     desc:'+12% weapon damage per rank',  cost:40, maxRank:5,
    apply: () => {} },
  { id:'town_armor',  icon:'ğŸ›¡ï¸',  name:'Bark Plating',     desc:'+6% damage reduction per rank',cost:55, maxRank:4,
    apply: () => {} },
  { id:'town_regen',  icon:'ğŸ©¸',  name:'Dark Sap',         desc:'+1 HP regen/sec per rank',     cost:50, maxRank:4,
    apply: () => {} },
  { id:'town_energy', icon:'âš¡',  name:'Energy Crystal',   desc:'+15 starting energy per rank', cost:60, maxRank:4,
    apply: () => {} },
  { id:'town_magnet', icon:'ğŸ§²',  name:'Lure Glyph',       desc:'+25% pickup radius per rank',  cost:45, maxRank:3,
    apply: () => {} },
];

// Persistent state (survives runs)
let gold = 0;
let townUpgrades = {}; // { upgradeId: rank }

const ENEMY_TYPES = [
  { name: 'Sunbeam Sprite', emoji: 'âœ¨', spriteKey: 'sunsprite',  hp: 18,  speed: 90,  xp: 5,  dmg: 8,  color: '#ffd700', size: 16 },
  { name: 'Happy Honeybee', emoji: 'ğŸ', spriteKey: 'honeybee',   hp: 12,  speed: 145, xp: 7,  dmg: 6,  color: '#f0c040', size: 14 },
  { name: 'Morning Dew',    emoji: 'ğŸ’§', spriteKey: 'dewdrop',    hp: 35,  speed: 60,  xp: 10, dmg: 12, color: '#89d4f5', size: 20 },
  { name: 'Daybloom',       emoji: 'ğŸŒ¸', spriteKey: 'daybloom',   hp: 55,  speed: 40,  xp: 15, dmg: 15, color: '#ffb7c5', size: 22 },
  { name: 'Gleaming Gem',   emoji: 'ğŸ’', spriteKey: 'gem',        hp: 80,  speed: 75,  xp: 25, dmg: 20, color: '#a0f0ff', size: 24 },
];

const BOSS_TYPES = [
  { name: 'Grand Sunkeeper', emoji: 'â˜€ï¸', spriteKey: 'boss_sunkeeper', hp: 500, speed: 55, xp: 150, dmg: 30, color: '#ff9900', size: 45, boss: true },
  { name: 'Queen Blossom',   emoji: 'ğŸŒº', spriteKey: 'boss_blossom',   hp: 400, speed: 65, xp: 120, dmg: 25, color: '#ff69b4', size: 40, boss: true },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPRITE ASSET SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HOW TO USE CUSTOM SPRITES:
//   1. Place PNG files in the same folder as this HTML (or any accessible URL)
//   2. Set the 'src' for the entity you want to replace (null = use emoji)
//   3. Tune 'scale' (default 1.0) to make sprite bigger/smaller relative to hitbox
//   4. Tune 'offsetY' (default 0) to shift sprite up/down (negative = up)
//   5. Recommended size: 128Ã—128 or 256Ã—256 pixels, transparent PNG
//   6. The game auto-falls back to emoji if a sprite fails to load
//
// ENTITY KEY REFERENCE:
//   Raiders:  squirrel | beaver | catthulu | cobra | honker
//   Enemies:  sunsprite | honeybee | dewdrop | daybloom | gem
//   Bosses:   boss_sunkeeper | boss_blossom
//   UI:       titleBg (full-screen title background image)

const SPRITE_CONFIG = {
  // â”€â”€ RAIDERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // src:     path to PNG/JPG (null = use emoji fallback)
  //          NOTE: use PNG with transparency for best results.
  //          JPG files will show the background color.
  // scale:   size multiplier relative to the hitbox
  // offsetY: vertical shift in pixels (negative = up)
  squirrel:       { src: null,            scale: 1.0,  offsetY: 0  },
  beaver:         { src: 'beaver.jpg',    scale: 1.4,  offsetY: -6 }, // sprite sheet â€” animated
  catthulu:       { src: null,            scale: 1.1,  offsetY: -2 },
  cobra:          { src: null,            scale: 1.0,  offsetY: 0  },
  honker:         { src: null,            scale: 1.0,  offsetY: 0  },
  // â”€â”€ ENEMIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sunsprite:      { src: null,            scale: 0.9,  offsetY: 0  },
  honeybee:       { src: null,            scale: 0.85, offsetY: 0  },
  dewdrop:        { src: null,            scale: 1.0,  offsetY: 0  },
  daybloom:       { src: null,            scale: 1.0,  offsetY: 0  },
  gem:            { src: null,            scale: 0.95, offsetY: 0  },
  // â”€â”€ BOSSES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  boss_sunkeeper: { src: null,            scale: 1.2,  offsetY: -4 },
  boss_blossom:   { src: null,            scale: 1.1,  offsetY: -2 },
  // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  titleBg:        { src: 'title_bg_img.png' },
};

const SPRITES = {}; // loaded images keyed by id

function loadSprites() {
  Object.entries(SPRITE_CONFIG).forEach(([key, cfg]) => {
    if (!cfg.src) return;
    const img = new Image();
    img.onload  = () => { SPRITES[key] = img; console.log('âœ… Sprite loaded:', key); };
    img.onerror = () => { console.warn('âš ï¸ Sprite failed to load:', key, cfg.src); };
    img.src = cfg.src;
  });
}

// Draw an entity using its sprite if loaded, otherwise fall back to emoji.
// Must be called inside ctx.save() / ctx.restore() with world-space translate applied.
function drawEntity(emoji, spriteKey, hitboxSize, alpha = 1, poisoned = false) {
  const cfg   = SPRITE_CONFIG[spriteKey] || {};
  const scale = cfg.scale ?? 1.0;
  const oy    = cfg.offsetY ?? 0;
  const sprite = SPRITES[spriteKey];
  const drawSize = hitboxSize * 2.2 * scale;

  ctx.globalAlpha = poisoned ? alpha * 0.55 : alpha;

  if (sprite && sprite.complete && sprite.naturalWidth > 0) {
    ctx.drawImage(sprite, -drawSize / 2, -drawSize / 2 + oy, drawSize, drawSize);
    if (poisoned) {
      ctx.globalCompositeOperation = 'source-atop';
      ctx.fillStyle = 'rgba(46,204,113,0.45)';
      ctx.fillRect(-drawSize / 2, -drawSize / 2 + oy, drawSize, drawSize);
      ctx.globalCompositeOperation = 'source-over';
    }
  } else {
    ctx.font = (hitboxSize * 2.2 * scale) + 'px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, 0, oy);
  }

  ctx.globalAlpha = 1;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPRITE ANIMATION SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Define sprite sheet animations per character.
// Each entry maps to a sprite sheet image with a grid of frames.
//
// HOW TO ADD YOUR OWN SPRITE SHEET:
//   1. Add entry to ANIM_SHEETS with your character's id
//   2. Set frameW/frameH to match one frame's pixel size
//   3. Define animations: row = grid row, start = first column, count = number of frames
//   4. Make sure SPRITE_CONFIG[id].src points to the file
//
// FRAME COORDINATES: frames are addressed as grid[col][row]
//   sx = (start + frameIndex) * frameW
//   sy = row * frameH
//
// â”€â”€â”€ BEAVER SPRITE SHEET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//   Sheet: 1024Ã—559px | 8 cols Ã— 5 rows | each frame: 128Ã—112px
//   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//   â”‚ Row 0: Front idle/walk      â€” 8 frames               â”‚
//   â”‚ Row 1: Side-view walk       â€” 8 frames               â”‚
//   â”‚ Row 2: Back walk (0-4) + Attack bats (5-7)           â”‚
//   â”‚ Row 3: Hurt/knockback (0-1) + Charge attack (2-4)    â”‚
//   â”‚ Row 4: Death lie-down (0-5) + Bat explosion (6-7)    â”‚
//   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

const ANIM_SHEETS = {
  beaver: {
    frameW:  128,
    frameH:  112,
    scale:   1.4,
    offsetY: -6,
    // â”€â”€ Animation definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // row:   which row in the sprite sheet grid (0 = top)
    // start: first column index
    // count: number of frames to play
    // fps:   frames per second
    // loop:  false = play once and hold last frame, then animator.done = true
    // flipX: true = mirror horizontally (use for left-facing from a right-facing row)
    //
    // State machine uses: idle_down/up/left/right, walk_down/up/left/right
    // Fallback chain: if a named anim doesn't exist, falls back to nearest available
    animations: {
      // â”€â”€ IDLE (stopped, facing a direction) â”€â”€
      idle_down:   { row: 0, start: 0, count: 4, fps: 5  },          // front-facing idle
      idle_up:     { row: 2, start: 0, count: 1, fps: 4  },          // back, first frame only
      idle_right:  { row: 1, start: 0, count: 1, fps: 4  },          // side, first frame
      idle_left:   { row: 1, start: 0, count: 1, fps: 4, flipX: true },

      // â”€â”€ WALK â”€â”€
      walk_down:   { row: 0, start: 0, count: 4, fps: 9  },          // front walk (row 0)
      walk_up:     { row: 2, start: 0, count: 5, fps: 10 },          // back walk
      walk_right:  { row: 1, start: 0, count: 8, fps: 12 },          // side walk, facing right
      walk_left:   { row: 1, start: 0, count: 8, fps: 12, flipX: true }, // mirrored

      // â”€â”€ COMBAT â”€â”€
      attack:      { row: 2, start: 5, count: 3, fps: 16, loop: false },
      hurt:        { row: 3, start: 0, count: 2, fps: 12, loop: false },
      charge:      { row: 3, start: 2, count: 3, fps: 14, loop: false },

      // â”€â”€ DEATH â”€â”€
      death:       { row: 4, start: 0, count: 6, fps: 7,  loop: false },
    }
  },
  // â”€â”€ ADD YOUR OWN SHEETS HERE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Template:
  // squirrel: {
  //   frameW: 64, frameH: 64, scale: 1.2, offsetY: 0,
  //   animations: {
  //     idle_down:  { row: 0, start: 0, count: 4, fps: 6 },
  //     walk_right: { row: 1, start: 0, count: 6, fps: 10 },
  //     walk_left:  { row: 1, start: 0, count: 6, fps: 10, flipX: true },
  //     walk_up:    { row: 2, start: 0, count: 6, fps: 10 },
  //     walk_down:  { row: 3, start: 0, count: 6, fps: 10 },
  //     attack:     { row: 4, start: 0, count: 4, fps: 14, loop: false },
  //     hurt:       { row: 5, start: 0, count: 2, fps: 10, loop: false },
  //     death:      { row: 6, start: 0, count: 5, fps: 7,  loop: false },
  //   }
  // },
};

// â”€â”€ SpriteAnimator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class SpriteAnimator {
  constructor(sheetKey) {
    this.key     = sheetKey;
    this.def     = ANIM_SHEETS[sheetKey];
    this.img     = null;
    this.current = 'idle_down';
    this.frame   = 0;
    this.timer   = 0;
    this.done    = false;
    this.facing  = 'down';   // last movement direction: up | down | left | right
    this._afterAnim = null;

    if (this.def && SPRITE_CONFIG[sheetKey] && SPRITE_CONFIG[sheetKey].src) {
      const i = new Image();
      i.onload = () => { this.img = i; };
      i.src = SPRITE_CONFIG[sheetKey].src;
    }
  }

  // Returns the animation definition, falling back through a priority chain
  // if the exact name isn't defined in this sheet.
  _resolve(name) {
    const anims = this.def.animations;
    if (anims[name]) return { key: name, def: anims[name] };
    // Fallback: directional â†’ generic variants
    const fallbacks = {
      idle_left:  ['idle_right', 'idle_down', 'walk_right', 'walk_down'],
      idle_right: ['idle_down',  'walk_right', 'walk_down'],
      idle_up:    ['idle_down',  'walk_up',    'walk_down'],
      idle_down:  ['walk_down',  'idle_right', 'walk_right'],
      walk_left:  ['walk_right', 'walk_down',  'idle_down'],
      walk_right: ['walk_down',  'idle_right', 'idle_down'],
      walk_up:    ['walk_down',  'walk_right', 'idle_down'],
      walk_down:  ['walk_right', 'idle_down'],
    };
    for (const fb of (fallbacks[name] || [])) {
      if (anims[fb]) return { key: fb, def: anims[fb] };
    }
    // Final fallback: first animation in the sheet
    const first = Object.keys(anims)[0];
    return { key: first, def: anims[first] };
  }

  // Play an animation by name. force=true restarts even if already playing.
  play(name, force = false) {
    if (!this.def) return;
    const resolved = this._resolve(name);
    if (this.current === resolved.key && !force) return;
    this.current    = resolved.key;
    this.frame      = 0;
    this.timer      = 0;
    this.done       = false;
    this._afterAnim = null;
  }

  // Play a one-shot animation, then automatically transition to thenPlay.
  // If thenPlay is omitted, updatePlayerAnimator handles the transition naturally.
  playOnce(name, thenPlay = null) {
    if (!this.def) return;
    const resolved = this._resolve(name);
    if (this.current === resolved.key) return;
    this.current    = resolved.key;
    this.frame      = 0;
    this.timer      = 0;
    this.done       = false;
    this._afterAnim = thenPlay;
  }

  // Whether the current animation is a one-shot that should block state changes
  isOneShot() {
    if (!this.def) return false;
    const animDef = this.def.animations[this.current];
    return animDef && animDef.loop === false && !this.done;
  }

  update(dt) {
    if (!this.def) return;
    const animDef = this.def.animations[this.current];
    if (!animDef) return;
    const loop = animDef.loop !== false;
    this.timer += dt;
    const dur = 1 / (animDef.fps || 10);
    while (this.timer >= dur) {
      this.timer -= dur;
      this.frame++;
      if (this.frame >= animDef.count) {
        if (loop) {
          this.frame = 0;
        } else {
          this.frame = animDef.count - 1;
          this.done  = true;
          if (this._afterAnim) {
            const next = this._afterAnim;
            this._afterAnim = null;
            this.play(next, true);
          }
        }
      }
    }
  }

  // Draw the current frame at world origin. Call inside ctx.save()/ctx.restore().
  // Returns true if drawn, false if image not loaded yet (caller falls back to emoji).
  draw(ctx, hitboxSize, alpha = 1, poisoned = false) {
    if (!this.img || !this.def) return false;
    const animDef = this.def.animations[this.current];
    if (!animDef) return false;

    const { frameW, frameH, scale = 1.0, offsetY = 0 } = this.def;
    const sx    = (animDef.start + this.frame) * frameW;
    const sy    = animDef.row * frameH;
    const ds    = hitboxSize * 2.2 * scale;
    const doFlip = animDef.flipX || false;

    ctx.save();
    ctx.globalAlpha = poisoned ? alpha * 0.55 : alpha;
    if (doFlip) ctx.scale(-1, 1);

    ctx.drawImage(this.img, sx, sy, frameW, frameH, -ds / 2, -ds / 2 + offsetY, ds, ds);

    if (poisoned) {
      ctx.globalCompositeOperation = 'source-atop';
      ctx.fillStyle = 'rgba(46,204,113,0.45)';
      ctx.fillRect(-ds / 2, -ds / 2 + offsetY, ds, ds);
      ctx.globalCompositeOperation = 'source-over';
    }
    ctx.restore();
    ctx.globalAlpha = 1;
    return true;
  }
}

// â”€â”€ Player animation state machine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Chooses the correct directional animation based on movement and game state.
// Direction priority: if moving diagonally, horizontal beats vertical when roughly equal.
function updatePlayerAnimator(dt, moveX, moveY) {
  if (!player.animator) return;
  const anim = player.animator;
  anim.update(dt);

  // HURT: overrides everything (except death)
  if (player.invTime > 0.4 && anim.current !== 'death') {
    if (!anim.isOneShot() || anim.current !== 'hurt') {
      anim.playOnce('hurt');
    }
    return;
  }

  // ONE-SHOTS (attack, hurt, charge): let them finish before overriding
  if (anim.isOneShot()) return;

  // Determine direction from movement input
  const moving = moveX !== 0 || moveY !== 0;

  if (moving) {
    let dir;
    if (Math.abs(moveX) > Math.abs(moveY) * 0.6) {
      // Dominant horizontal
      dir = moveX > 0 ? 'right' : 'left';
    } else if (Math.abs(moveY) > Math.abs(moveX) * 0.6) {
      // Dominant vertical
      dir = moveY > 0 ? 'down' : 'up';
    } else {
      // True diagonal â€” pick horizontal
      dir = moveX > 0 ? 'right' : 'left';
    }
    anim.facing = dir;
    anim.play('walk_' + dir);
  } else {
    // Standing still â€” idle facing last direction
    anim.play('idle_' + (anim.facing || 'down'));
  }
}
let audioCtx = null;
let masterGain = null;
let musicNodes = [];
let musicPlaying = false;
let muted = false;
let bgMusic = null;
let lastShootSfx = 0;   // throttle shoot sounds
let lastXpSfx = 0;      // throttle xp sounds
let lastHurtSfx = 0;    // throttle hurt sounds

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.45;
    masterGain.connect(audioCtx.destination);
  } catch(e) { console.warn('Web Audio not available:', e); }
}

// â”€â”€ SFX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playSFX(type) {
  if (!audioCtx || muted) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  const t = audioCtx.currentTime;

  const osc = (freq, type_, dur, gainVal, freqEnd) => {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type_;
    o.frequency.setValueAtTime(freq, t);
    if (freqEnd) o.frequency.exponentialRampToValueAtTime(freqEnd, t + dur);
    g.gain.setValueAtTime(gainVal, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    o.connect(g); g.connect(masterGain);
    o.start(t); o.stop(t + dur + 0.01);
  };

  const noise = (dur, gainVal, hpFreq = 0) => {
    const buf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * dur), audioCtx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(gainVal, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    src.connect(g);
    if (hpFreq > 0) {
      const f = audioCtx.createBiquadFilter();
      f.type = 'bandpass'; f.frequency.value = hpFreq;
      g.connect(f); f.connect(masterGain);
    } else {
      g.connect(masterGain);
    }
    src.start(t);
  };

  switch (type) {
    case 'shoot_laser':    osc(900, 'square',   0.08, 0.12, 450); break;
    case 'shoot_bite':     osc(320, 'sawtooth', 0.07, 0.18, 180); break;
    case 'shoot_tentacle': osc(260, 'square',   0.09, 0.14, 130); break;
    case 'shoot_poison':   osc(700, 'sine',     0.05, 0.08, 1100); break;
    case 'shoot_spectral': osc(500, 'triangle', 0.10, 0.10, 800); break;

    case 'hit':
      noise(0.06, 0.28, 1100);
      break;

    case 'enemy_die':
      osc(380, 'sawtooth', 0.18, 0.22, 70);
      noise(0.12, 0.15, 600);
      break;

    case 'player_hurt':
      osc(180, 'square', 0.22, 0.38, 90);
      noise(0.15, 0.20, 200);
      break;

    case 'levelup':
      [523, 659, 784, 1047].forEach((f, i) => {
        const start = t + i * 0.08;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle'; o.frequency.value = f;
        g.gain.setValueAtTime(0.28, start);
        g.gain.exponentialRampToValueAtTime(0.001, start + 0.22);
        o.connect(g); g.connect(masterGain);
        o.start(start); o.stop(start + 0.25);
      });
      break;

    case 'xp':
      osc(1300, 'sine', 0.05, 0.06, 1700);
      break;

    case 'boss':
      [110, 146, 196].forEach((f, i) => {
        const start = t + i * 0.18;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.value = f;
        g.gain.setValueAtTime(0.38, start);
        g.gain.exponentialRampToValueAtTime(0.001, start + 0.5);
        o.connect(g); g.connect(masterGain);
        o.start(start); o.stop(start + 0.55);
      });
      break;

    case 'gameover':
      [392, 330, 294, 220].forEach((f, i) => {
        const start = t + i * 0.22;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'triangle'; o.frequency.value = f;
        g.gain.setValueAtTime(0.35, start);
        g.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
        o.connect(g); g.connect(masterGain);
        o.start(start); o.stop(start + 0.45);
      });
      break;

    case 'supermove':
      // Big ascending sweep + impact
      osc(200, 'sawtooth', 0.05, 0.4, 900);
      osc(400, 'square',   0.10, 0.3, 1200);
      [1, 2, 3, 4, 5].forEach(i => {
        const start2 = t + i * 0.04;
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = 'triangle'; o2.frequency.value = 300 * i;
        g2.gain.setValueAtTime(0.15, start2);
        g2.gain.exponentialRampToValueAtTime(0.001, start2 + 0.25);
        o2.connect(g2); g2.connect(masterGain);
        o2.start(start2); o2.stop(start2 + 0.28);
      });
      break;
  }
}

// â”€â”€ PROCEDURAL MUSIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Dark minor-pentatonic chiptune. Three layers: bass, melody, percussion.
const _N = { // note frequencies
  C2:65.4, Eb2:77.8, G2:98.0, Bb2:116.5,
  C3:130.8, Eb3:155.6, G3:196.0, Bb3:233.1, C4:261.6,
  D4:293.7, Eb4:311.1, G4:392.0, Bb4:466.2, C5:523.3,
};
const BASS = ['C2','C2','G2','C2','Bb2','Bb2','G2','Bb2','Eb2','Eb2','Bb2','Eb2','G2','G2','Eb2','G2'];
const MELO = [
  'C4', null, 'Eb4', null, 'G4', 'Eb4', null, 'C4',
  'Bb3', null, 'G3',  null, 'Bb3','G3',  null, 'Eb3',
  'G4',  null, null,  'C4', 'Eb4',null,  'G3', null,
  'C4', 'D4', 'Eb4',  null, 'C4', null,  null,  null,
];
const PAD  = ['C3','Eb3','G3','Bb3','C3','Eb3','G3','Bb3'];
const STEP_SEC = 0.145;
let _seqStep = 0, _nextNote = 0, _schedTimer = null;

function startMusic() {
  if (bgMusic) return;
  bgMusic = new Audio('music.mp3'); // â† change filename here if needed
  bgMusic.loop = true;
  bgMusic.volume = muted ? 0 : 0.4;
  bgMusic.play().catch(() => {}); // silently handle autoplay block
}

function stopMusic() {
  if (!bgMusic) return;
  bgMusic.pause();
  bgMusic.currentTime = 0;
  bgMusic = null;
}

function _scheduleMusic() {
  if (!musicPlaying || !audioCtx) return;
  while (_nextNote < audioCtx.currentTime + 0.25) {
    _playMusicStep(_seqStep, _nextNote);
    _seqStep = (_seqStep + 1) % 32;
    _nextNote += STEP_SEC;
  }
  _schedTimer = setTimeout(_scheduleMusic, 60);
}

function _playMusicStep(step, time) {
  if (muted) return;
  const bassNote = BASS[step % BASS.length];
  const meloNote = MELO[step % MELO.length];
  const padNote  = PAD[step  % PAD.length];

  if (bassNote) _musOsc(_N[bassNote], 'square',   time, STEP_SEC * 0.85, 0.10);
  if (meloNote) _musOsc(_N[meloNote], 'triangle', time, STEP_SEC * 0.55, 0.07);
  // Pad â€” long held note every 8 steps
  if (step % 8 === 0 && padNote) _musOsc(_N[padNote], 'sine', time, STEP_SEC * 6, 0.04);
  // Kick (low thud) on beats 0, 8, 16, 24
  if (step % 8 === 0) _musKick(time);
  // Snare on step 4, 12, 20, 28
  if (step % 8 === 4) _musSnare(time);
  // Hi-hat every 2 steps
  if (step % 2 === 0) _musHihat(time);
}

function _musOsc(freq, type_, time, dur, gainVal) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type_; o.frequency.value = freq;
  g.gain.setValueAtTime(gainVal, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + dur);
  o.connect(g); g.connect(masterGain);
  o.start(time); o.stop(time + dur + 0.01);
  musicNodes.push(o);
}

function _musKick(time) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(160, time);
  o.frequency.exponentialRampToValueAtTime(40, time + 0.08);
  g.gain.setValueAtTime(0.5, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
  o.connect(g); g.connect(masterGain);
  o.start(time); o.stop(time + 0.14);
  musicNodes.push(o);
}

function _musSnare(time) {
  const buf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * 0.09), audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
  const src = audioCtx.createBufferSource(); src.buffer = buf;
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 1800;
  g.gain.setValueAtTime(0.18, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + 0.09);
  src.connect(f); f.connect(g); g.connect(masterGain);
  src.start(time);
  musicNodes.push(src);
}

function _musHihat(time) {
  const buf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * 0.04), audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
  const src = audioCtx.createBufferSource(); src.buffer = buf;
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 6000;
  g.gain.setValueAtTime(0.07, time);
  g.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
  src.connect(f); f.connect(g); g.connect(masterGain);
  src.start(time);
  musicNodes.push(src);
}

function setMute(isMuted) {
  muted = isMuted;
  if (masterGain) masterGain.gain.value = muted ? 0 : 0.45;
  if (bgMusic)    bgMusic.volume    = muted ? 0 : 0.4;
  if (titleMusic) titleMusic.volume = muted ? 0 : 0.35;
  document.getElementById('muteBtn').textContent = muted ? 'ğŸ”‡' : 'ğŸ”Š';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SAVE SYSTEM  (localStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SAVE_KEY = 'nibblenight_save';

function saveGame() {
  try {
    const data = {
      gold,
      townUpgrades,
      bestTime:  bestTime  || 0,
      totalKills: totalKills || 0,
      totalRuns:  totalRuns  || 0,
      v: 1,
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    showSaveToast();
  } catch(e) { console.warn('Save failed:', e); }
}

function loadGame() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (data.v !== 1) return false;
    gold         = data.gold         || 0;
    townUpgrades = data.townUpgrades || {};
    bestTime     = data.bestTime     || 0;
    totalKills   = data.totalKills   || 0;
    totalRuns    = data.totalRuns    || 0;
    return true;
  } catch(e) { return false; }
}

function resetSave() {
  localStorage.removeItem(SAVE_KEY);
  gold = 0; townUpgrades = {}; bestTime = 0; totalKills = 0; totalRuns = 0;
}

function showSaveToast() {
  const el = document.getElementById('saveToast');
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2200);
}

let bestTime   = 0;
let totalKills = 0;
let totalRuns  = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TITLE SCREEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let titleCanvas, titleCtx;
let titleParticles = [];
let titleRaf = null;
let titleAnimTime = 0;

function initTitleScreen() {
  titleCanvas = document.getElementById('titleCanvas');
  titleCtx    = titleCanvas.getContext('2d');
  titleCanvas.width  = window.innerWidth;
  titleCanvas.height = window.innerHeight;

  // Spawn floating particles
  titleParticles = [];
  for (let i = 0; i < 80; i++) {
    titleParticles.push({
      x: Math.random() * titleCanvas.width,
      y: Math.random() * titleCanvas.height,
      vx: (Math.random() - 0.5) * 0.4,
      vy: -0.3 - Math.random() * 0.5,
      size: 1 + Math.random() * 3,
      alpha: 0.1 + Math.random() * 0.5,
      color: Math.random() < 0.4 ? '#8b5cf6' :
             Math.random() < 0.6 ? '#c084fc' : '#fff',
      life: Math.random(),
    });
  }
  animateTitleScreen();

  // Show save info if exists
  const hasSave = loadGame();
  if (hasSave && (gold > 0 || bestTime > 0)) {
    document.getElementById('titleSaveBadge').style.display = 'flex';
    document.getElementById('titleSaveGold').textContent = gold;
    const bm = Math.floor(bestTime/60).toString().padStart(2,'0');
    const bs = Math.floor(bestTime%60).toString().padStart(2,'0');
    document.getElementById('titleBestTime').textContent = bestTime > 0 ? `${bm}:${bs}` : '--:--';
  }
}

function animateTitleScreen() {
  titleAnimTime += 0.016;
  const W = titleCanvas.width, H = titleCanvas.height;
  titleCtx.clearRect(0, 0, W, H);

  // â”€â”€ Background: use title art image if loaded, else procedural fallback â”€â”€
  if (SPRITES.titleBg && SPRITES.titleBg.complete && SPRITES.titleBg.naturalWidth > 0) {
    // Scale image to cover the canvas, centred
    const img = SPRITES.titleBg;
    const scale = Math.max(W / img.naturalWidth, H / img.naturalHeight);
    const dw = img.naturalWidth  * scale;
    const dh = img.naturalHeight * scale;
    const dx = (W - dw) / 2;
    const dy = (H - dh) / 2;
    titleCtx.drawImage(img, dx, dy, dw, dh);

    // Dark vignette overlay so UI text is readable
    const vig = titleCtx.createRadialGradient(W/2, H/2, H*0.15, W/2, H/2, H*0.85);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.72)');
    titleCtx.fillStyle = vig;
    titleCtx.fillRect(0, 0, W, H);

    // Bottom gradient to ground the UI
    const bot = titleCtx.createLinearGradient(0, H*0.7, 0, H);
    bot.addColorStop(0, 'rgba(0,0,0,0)');
    bot.addColorStop(1, 'rgba(5,3,15,0.85)');
    titleCtx.fillStyle = bot;
    titleCtx.fillRect(0, H*0.7, W, H*0.3);

  } else {
    // â”€â”€ Procedural fallback (no image) â”€â”€
    const bg = titleCtx.createRadialGradient(W*0.5, H*0.3, 0, W*0.5, H*0.5, W*0.8);
    bg.addColorStop(0, '#1a0a2e');
    bg.addColorStop(0.5, '#0d0818');
    bg.addColorStop(1, '#050510');
    titleCtx.fillStyle = bg;
    titleCtx.fillRect(0, 0, W, H);

    // Moon
    const moonX = W * 0.78, moonY = H * 0.18;
    const moonGrad = titleCtx.createRadialGradient(moonX, moonY, 0, moonX, moonY, 55);
    moonGrad.addColorStop(0, 'rgba(255,250,230,0.95)');
    moonGrad.addColorStop(0.7, 'rgba(230,220,255,0.6)');
    moonGrad.addColorStop(1, 'rgba(139,92,246,0)');
    titleCtx.fillStyle = moonGrad;
    titleCtx.beginPath();
    titleCtx.arc(moonX, moonY, 55, 0, Math.PI * 2);
    titleCtx.fill();

    // Treeline silhouette
    titleCtx.fillStyle = 'rgba(5,3,12,0.95)';
    titleCtx.beginPath();
    titleCtx.moveTo(0, H);
    const treeCount = Math.ceil(W / 28);
    for (let i = 0; i <= treeCount; i++) {
      const tx = (i / treeCount) * W;
      const seed  = Math.sin(i * 7.3 + 1.2) * 0.5 + 0.5;
      const seed2 = Math.sin(i * 13.1 + 5.5) * 0.5 + 0.5;
      const baseH = H * (0.68 + seed * 0.12);
      const tipH  = baseH - (20 + seed2 * 60);
      titleCtx.lineTo(tx - 14, baseH);
      titleCtx.lineTo(tx, tipH);
      titleCtx.lineTo(tx + 14, baseH);
    }
    titleCtx.lineTo(W, H);
    titleCtx.closePath();
    titleCtx.fill();
  }

  // â”€â”€ Floating sparkle particles (on top of everything) â”€â”€
  titleParticles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    p.life += 0.004;
    if (p.y < -10 || p.life > 1) {
      p.x = Math.random() * W;
      p.y = H + 10;
      p.life = 0;
    }
    const a = p.alpha * Math.sin(p.life * Math.PI) * 0.7;
    titleCtx.globalAlpha = a;
    titleCtx.fillStyle = p.color;
    titleCtx.shadowColor = p.color;
    titleCtx.shadowBlur = 8;
    titleCtx.beginPath();
    titleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    titleCtx.fill();
  });
  titleCtx.globalAlpha = 1;
  titleCtx.shadowBlur = 0;

  titleRaf = requestAnimationFrame(animateTitleScreen);
}

function stopTitleAnimation() {
  if (titleRaf) { cancelAnimationFrame(titleRaf); titleRaf = null; }
}

function showTitleScreen() {
  loadGame();
  state = 'title';
  showScreen('titleScreen');
  initTitleScreen();
  // NOTE: title music is started in leaveTitleScreen() after a user gesture,
  // because browsers block audio that isn't triggered by an interaction.
}

function leaveTitleScreen() {
  if (state !== 'title') return;
  state = 'leaving_title'; // prevent double-fire

  // Audio must start inside the user gesture handler â€” this is that handler
  initAudio();
  startTitleMusic();

  const el = document.getElementById('titleScreen');
  el.classList.add('fade-out');
  stopTitleAnimation();
  setTimeout(() => {
    el.classList.add('hidden');
    el.classList.remove('fade-out');
    buildCharSelect();
    showScreen('selectScreen');
    state = 'select';
  }, 600);
}

// â”€â”€â”€ title music (separate from battle music) â”€â”€â”€
let titleMusic = null;
function startTitleMusic() {
  if (titleMusic) return;
  titleMusic = new Audio('titlemusic.mp3');
  titleMusic.loop = true;
  titleMusic.volume = muted ? 0 : 0.35;
  titleMusic.play().catch(() => {});
}
function stopTitleMusic() {
  if (!titleMusic) return;
  titleMusic.pause();
  titleMusic.currentTime = 0;
  titleMusic = null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let canvas, ctx;
let state = 'title'; // title | select | playing | levelup | paused | town | gameover
let prevState = 'playing';
let selectedChar = null;
let player, enemies, projectiles, xpGems, energyOrbs, goldCoins, floatTexts, particles;
let camera = { x: 0, y: 0 };
let keys = {}, justPressed = {};
let kills = 0, elapsed = 0, gameStartTime = 0;
let lastFrame = 0, lastSpawn = 0, spawnInterval = 2.0;
let lastBossTime = 0;
let xpToNext = 20;
let totalXP = 0, runGold = 0;
let pendingUpgrades = false;
let killStreak = 0, streakTimer = 0;
let waveNumber = 0, lastWaveShown = -1;
let activeBoss = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHARACTER SELECT UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildCharSelect() {
  const grid = document.getElementById('charGrid');
  grid.innerHTML = '';
  CHARS.forEach(c => {
    const card = document.createElement('div');
    card.className = 'char-card';
    card.style.setProperty('--color', c.color);
    card.style.setProperty('--glow', c.glow);
    card.style.setProperty('--shadow', c.shadow);
    const sprite = SPRITES[c.id];
    const portraitHTML = sprite
      ? `<img src="${SPRITE_CONFIG[c.id].src}" alt="${c.name}">`
      : `<span class="char-portrait-emoji">${c.emoji}</span>`;

    card.innerHTML = `
      <div class="char-portrait">${portraitHTML}</div>
      <div class="char-name">${c.name}</div>
      <div class="char-desc">${c.desc}</div>
      <div style="margin-top:0.5em;font-size:0.65rem;color:#6b7280;background:rgba(255,255,255,0.04);border-radius:8px;padding:4px 6px;line-height:1.4">
        ${c.ultimate.icon} <span style="color:#fde68a;font-weight:700">${c.ultimate.name}</span><br>
        <span style="color:#4b5563">${c.ultimate.desc}</span>
      </div>
      <div class="char-stat"><span>HP</span><span>SPD</span><span>DMG</span></div>
      <div class="stat-bar"><div class="stat-fill" style="width:${c.stats.hp}%;background:${c.color}"></div></div>
      <div class="stat-bar"><div class="stat-fill" style="width:${c.stats.spd}%;background:${c.color}"></div></div>
      <div class="stat-bar"><div class="stat-fill" style="width:${c.stats.dmg}%;background:${c.color}"></div></div>
    `;
    card.onclick = () => {
      document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected'));
      card.classList.add('selected');
      selectedChar = c;
      document.getElementById('startBtn').disabled = false;
    };
    grid.appendChild(card);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame() {
  const c = selectedChar;

  // Build town bonus stats
  const tb = {
    hp:     (townUpgrades['town_hp']    || 0) * 20,
    spd:    1 + (townUpgrades['town_spd']   || 0) * 0.08,
    dmg:    1 + (townUpgrades['town_dmg']   || 0) * 0.12,
    armor:  (townUpgrades['town_armor'] || 0) * 0.06,
    regen:  (townUpgrades['town_regen'] || 0) * 1,
    energy: (townUpgrades['town_energy']|| 0) * 15,
    magnet: 1 + (townUpgrades['town_magnet']|| 0) * 0.25,
  };

  player = {
    x: 0, y: 0,
    hp: c.hp + tb.hp, maxHp: c.hp + tb.hp,
    speed: c.speed * tb.spd,
    emoji: c.emoji, color: c.color,
    weapon: { ...c.weapon, damage: c.weapon.damage * tb.dmg },
    attackTimer: 0,
    xp: 0, level: 1,
    invTime: 0,
    regen: tb.regen, regenTimer: 0,
    pickupRadius: 80 * tb.magnet,
    armor: tb.armor,
    size: 20,
    energy: tb.energy, maxEnergy: 100,
    superReady: tb.energy >= 100,
    superCD: 0,
    // Sprite animator â€” only created if a sheet is defined for this character
    animator: ANIM_SHEETS[c.id] ? new SpriteAnimator(c.id) : null,
    lastMoveX: 0, lastMoveY: 0,
  };
  enemies = []; projectiles = []; xpGems = []; energyOrbs = []; goldCoins = [];
  floatTexts = []; particles = [];
  kills = 0; elapsed = 0; lastSpawn = 0; spawnInterval = 2.0; lastBossTime = 0;
  xpToNext = 20; totalXP = 0; runGold = 0;
  keys = {}; justPressed = {};
  killStreak = 0; streakTimer = 0;
  waveNumber = 0; lastWaveShown = -1;
  activeBoss = null;
  camera = { x: 0, y: 0 };
  gameStartTime = performance.now();
  lastFrame = performance.now();
  lastShootSfx = 0; lastXpSfx = 0; lastHurtSfx = 0;

  initAudio();
  stopTitleMusic();
  stopMusic();
  startMusic();

  showScreen('hud');
  state = 'playing';
  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCREEN MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showScreen(id) {
  ['titleScreen','selectScreen','hud','levelupScreen','pauseScreen','townScreen','gameoverScreen'].forEach(s => {
    document.getElementById(s).classList.add('hidden');
  });
  if (id) document.getElementById(id).classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gameLoop(ts) {
  if (state === 'gameover') return;
  const dt = Math.min((ts - lastFrame) / 1000, 0.05);
  lastFrame = ts;

  if (state === 'playing') {
    elapsed = (ts - gameStartTime) / 1000;
    update(dt);
  }
  justPressed = {};
  render();
  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function update(dt) {
  handleSupermoveInput();
  movePlayer(dt);
  updateProjectiles(dt);
  updateEnemies(dt);
  updateXPGems(dt);
  updateEnergyOrbs(dt);
  updateGoldCoins(dt);
  updateParticles(dt);
  spawnEnemies(dt);
  attackLogic(dt);
  regenLogic(dt);
  updateStreak(dt);
  updateWave();
  updateBossBar();
  updateHUD();
}

function updateStreak(dt) {
  if (killStreak > 0) {
    streakTimer -= dt;
    if (streakTimer <= 0) { killStreak = 0; }
  }
  const el = document.getElementById('streakDisplay');
  if (killStreak >= 3) {
    el.textContent = 'ğŸ”¥ x' + killStreak + ' Streak!';
    el.classList.add('show');
  } else {
    el.classList.remove('show');
  }
}

function updateWave() {
  const newWave = 1 + Math.floor(elapsed / 30);
  if (newWave !== waveNumber) {
    waveNumber = newWave;
  }
  if (waveNumber !== lastWaveShown) {
    lastWaveShown = waveNumber;
    const el = document.getElementById('waveBadge');
    el.textContent = 'ğŸŒŠ Wave ' + waveNumber;
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 2500);
  }
}

function updateBossBar() {
  // Find active boss
  const boss = enemies.find(e => e.boss);
  const bar = document.getElementById('bossHPBar');
  if (boss) {
    activeBoss = boss;
    bar.style.display = 'block';
    document.getElementById('bossName').textContent = boss.name || 'Boss';
    document.getElementById('bossFill').style.width = Math.max(0, (boss.hp / boss.maxHp) * 100) + '%';
  } else if (activeBoss) {
    activeBoss = null;
    bar.style.display = 'none';
  }
}

function movePlayer(dt) {
  let dx = 0, dy = 0;
  if (keys['ArrowLeft']  || keys['a']) dx -= 1;
  if (keys['ArrowRight'] || keys['d']) dx += 1;
  if (keys['ArrowUp']    || keys['w']) dy -= 1;
  if (keys['ArrowDown']  || keys['s']) dy += 1;
  const len = Math.sqrt(dx*dx + dy*dy);
  if (len > 0) { dx /= len; dy /= len; }
  player.x += dx * player.speed * dt;
  player.y += dy * player.speed * dt;
  player.lastMoveX = dx;
  player.lastMoveY = dy;
  camera.x = player.x - canvas.width / 2;
  camera.y = player.y - canvas.height / 2;
  if (player.invTime > 0) player.invTime -= dt;
  updatePlayerAnimator(dt, dx, dy);
}

function handleSupermoveInput() {
  if (!justPressed[' ']) return;
  if (player.energy < player.maxEnergy) return;
  if (player.superCD > 0) return;
  player.energy = 0;
  player.superReady = false;
  player.superCD = 0.5; // brief lockout
  playSFX('supermove');
  selectedChar.ultimate.activate(player);
  spawnFloatText(player.x, player.y - 70, 'âœ¨ ' + selectedChar.ultimate.name + '!', selectedChar.ultimate.color);
}

function triggerSuperFlash(color) {
  const el = document.getElementById('superFlash');
  el.style.background = color;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 180);
}

// â”€â”€ ENERGY ORBS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateEnergyOrbs(dt) {
  for (let i = energyOrbs.length - 1; i >= 0; i--) {
    const o = energyOrbs[i];
    const d = dist(player, o);
    if (d < player.pickupRadius) {
      const dx = player.x - o.x, dy = player.y - o.y;
      o.x += (dx/d) * 280 * dt;
      o.y += (dy/d) * 280 * dt;
    }
    if (dist(player, o) < 18) {
      player.energy = Math.min(player.maxEnergy, player.energy + o.value);
      energyOrbs.splice(i, 1);
      if (player.energy >= player.maxEnergy) {
        player.superReady = true;
        player.energy = player.maxEnergy;
      }
    }
  }
}

// â”€â”€ GOLD COINS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateGoldCoins(dt) {
  for (let i = goldCoins.length - 1; i >= 0; i--) {
    const c = goldCoins[i];
    const d = dist(player, c);
    if (d < player.pickupRadius + 20) {
      const dx = player.x - c.x, dy = player.y - c.y;
      c.x += (dx/d) * 260 * dt;
      c.y += (dy/d) * 260 * dt;
    }
    if (dist(player, c) < 18) {
      gold += c.value;
      runGold += c.value;
      goldCoins.splice(i, 1);
      document.getElementById('goldCounter').textContent = 'ğŸª™ ' + gold;
    }
  }
}

function regenLogic(dt) {
  if (player.regen <= 0) return;
  player.regenTimer += dt;
  if (player.regenTimer >= 1) {
    player.regenTimer -= 1;
    player.hp = Math.min(player.hp + player.regen, player.maxHp);
  }
}

function attackLogic(dt) {
  player.attackTimer -= dt;
  if (player.attackTimer > 0) return;
  player.attackTimer = player.weapon.cooldown;
  fireWeapon();
}

function fireWeapon() {
  // Trigger attack animation (one-shot; state machine resumes walk/idle when done)
  if (player.animator) player.animator.playOnce('attack');

  const w = player.weapon;
  const target = getNearestEnemy(w.range);
  const count = w.count || 1;

  if (w.type === 'tentacle') {
    // Fire in all directions, no target needed
    for (let i = 0; i < count; i++) {
      spawnProjectile((i / count) * Math.PI * 2, w);
    }
  } else if (w.type === 'spectral') {
    // Fire evenly spread in all directions
    for (let i = 0; i < count; i++) {
      spawnProjectile((i / count) * Math.PI * 2, w);
    }
  } else if (w.type === 'poison') {
    if (!target) return;
    const baseAngle = Math.atan2(target.y - player.y, target.x - player.x);
    const spread = w.spread || 0.3;
    for (let i = 0; i < count; i++) {
      spawnProjectile(baseAngle + (i - (count-1)/2) * spread, w);
    }
  } else {
    // laser, bite â€” aim at nearest enemy
    if (!target && w.type !== 'laser') return;
    const angle = target
      ? Math.atan2(target.y - player.y, target.x - player.x)
      : -Math.PI / 2;
    for (let i = 0; i < count; i++) {
      const spread = (count > 1) ? (i - (count-1)/2) * 0.15 : 0;
      spawnProjectile(angle + spread, w);
    }
  }
}

function spawnProjectile(angle, w) {
  const speed = w.type === 'tentacle' ? 280 : w.type === 'bite' ? 220 :
                w.type === 'poison' ? 320 : 350;
  // Throttled shoot SFX (max once per 80ms to avoid audio spam)
  const now = performance.now();
  if (now - lastShootSfx > 80) {
    lastShootSfx = now;
    playSFX('shoot_' + w.type);
  }
  projectiles.push({
    x: player.x, y: player.y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    damage: w.damage,
    pierce: w.pierce || 1,
    pierceLeft: w.pierce || 1,
    range: w.range,
    distTravelled: 0,
    type: w.type,
    lifesteal: w.lifesteal || 0,
    hit: new Set(),
    // Visual
    size: w.type === 'laser' ? 5 : w.type === 'tentacle' ? 8 :
          w.type === 'bite' ? 10 : w.type === 'poison' ? 6 : 7,
    color: w.type === 'laser' ? '#ff9f43' :
           w.type === 'bite' ? '#ef4444' :
           w.type === 'tentacle' ? '#9b59b6' :
           w.type === 'poison' ? '#2ecc71' : '#74b9ff',
  });
}

function getNearestEnemy(range) {
  let nearest = null, nearDist = Infinity;
  for (const e of enemies) {
    const d = dist(player, e);
    if (d < range && d < nearDist) { nearest = e; nearDist = d; }
  }
  return nearest;
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.distTravelled += Math.sqrt(p.vx*p.vx + p.vy*p.vy) * dt;

    // Check enemy collisions
    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (p.hit.has(j)) continue;
      if (dist(p, e) < e.size + p.size) {
        p.hit.add(j);
        p.pierceLeft--;
        damageEnemy(e, j, p.damage, p.lifesteal);
        spawnHitParticles(e.x, e.y, p.color);
        if (p.type === 'poison') e.poisoned = (e.poisoned || 0) + 3;
        if (p.pierceLeft <= 0) { projectiles.splice(i, 1); break; }
      }
    }
    if (i < projectiles.length && p.distTravelled > p.range) {
      projectiles.splice(i, 1);
    }
  }
}

function damageEnemy(e, idx, dmg, lifesteal) {
  e.hp -= dmg;
  playSFX('hit');
  if (lifesteal > 0) {
    player.hp = Math.min(player.hp + dmg * lifesteal, player.maxHp);
    spawnFloatText(player.x, player.y - 30, '+' + Math.floor(dmg * lifesteal), '#2ecc71');
  }
  spawnFloatText(e.x, e.y - 20, '-' + Math.floor(dmg), '#fff');
  if (e.hp <= 0) {
    kills++;
    killStreak++;
    streakTimer = 4.0; // reset streak timeout
    totalKills++;
    playSFX('enemy_die');
    // Drop XP gems
    const gemCount = e.boss ? 8 : 1;
    for (let g = 0; g < gemCount; g++) {
      xpGems.push({
        x: e.x + (Math.random()-0.5)*30,
        y: e.y + (Math.random()-0.5)*30,
        value: Math.floor(e.xp / gemCount),
      });
    }
    // Drop energy orb (40% chance, 80% for boss)
    if (Math.random() < (e.boss ? 0.8 : 0.4)) {
      energyOrbs.push({
        x: e.x + (Math.random()-0.5)*20,
        y: e.y + (Math.random()-0.5)*20,
        value: e.boss ? 30 : 10 + Math.floor(Math.random() * 8),
      });
    }
    // Drop gold (50% for normal, 100% for boss)
    if (Math.random() < (e.boss ? 1.0 : 0.5)) {
      const gVal = e.boss
        ? 10 + Math.floor(Math.random()*15)
        : 1 + Math.floor(Math.random() * (e.size > 18 ? 4 : 2));
      goldCoins.push({
        x: e.x + (Math.random()-0.5)*20,
        y: e.y + (Math.random()-0.5)*20,
        value: gVal,
      });
    }
    spawnDeathParticles(e.x, e.y, e.color);
    enemies.splice(idx, 1);
  }
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    // Move toward player
    const dx = player.x - e.x, dy = player.y - e.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d > 0) {
      e.x += (dx/d) * e.speed * dt;
      e.y += (dy/d) * e.speed * dt;
    }
    // Poison tick
    if (e.poisoned > 0) {
      e.poisoned -= dt;
      e.poisonTick = (e.poisonTick || 0) + dt;
      if (e.poisonTick >= 0.5) {
        e.poisonTick = 0;
        e.hp -= 5;
        if (e.hp <= 0) {
          kills++;
          xpGems.push({ x: e.x, y: e.y, value: e.xp });
          if (Math.random() < 0.4) energyOrbs.push({ x: e.x, y: e.y, value: 10 });
          if (Math.random() < 0.5) goldCoins.push({ x: e.x, y: e.y, value: 1 + Math.floor(Math.random()*3) });
          spawnDeathParticles(e.x, e.y, e.color);
          enemies.splice(i, 1); continue;
        }
      }
    }
    // Damage player
    if (player.invTime <= 0 && d < e.size + player.size) {
      const dmgTaken = Math.max(1, Math.floor(e.dmg * (1 - player.armor)));
      player.hp -= dmgTaken;
      player.invTime = 0.6;
      spawnFloatText(player.x, player.y - 40, '-' + dmgTaken, '#ef4444');
      screenShake(0.3);
      const nowHurt = performance.now();
      if (nowHurt - lastHurtSfx > 300) { lastHurtSfx = nowHurt; playSFX('player_hurt'); }
      if (player.hp <= 0) { endGame(); return; }
    }
  }
}

function updateXPGems(dt) {
  for (let i = xpGems.length - 1; i >= 0; i--) {
    const g = xpGems[i];
    const d = dist(player, g);
    if (d < player.pickupRadius) {
      // Move toward player
      const dx = player.x - g.x, dy = player.y - g.y;
      g.x += (dx/d) * 300 * dt;
      g.y += (dy/d) * 300 * dt;
    }
    if (dist(player, g) < 18) {
      player.xp += g.value;
      totalXP += g.value;
      xpGems.splice(i, 1);
      const nowXp = performance.now();
      if (nowXp - lastXpSfx > 60) { lastXpSfx = nowXp; playSFX('xp'); }
      checkLevelUp();
    }
  }
}

function checkLevelUp() {
  while (player.xp >= xpToNext) {
    player.xp -= xpToNext;
    player.level++;
    xpToNext = Math.floor(xpToNext * 1.25 + 10);
    triggerLevelUp();
    break;
  }
}

function triggerLevelUp() {
  playSFX('levelup');
  state = 'levelup';
  showLevelUpScreen();
}

function showLevelUpScreen() {
  document.getElementById('levelupCurrent').textContent = `Level ${player.level - 1} â†’ ${player.level}`;
  const container = document.getElementById('upgradeCards');
  container.innerHTML = '';
  // Pick 3 random upgrades
  const pool = [...UPGRADES_POOL].sort(() => Math.random() - 0.5).slice(0, 3);
  pool.forEach(u => {
    const card = document.createElement('div');
    card.className = 'upgrade-card';
    card.innerHTML = `
      <div class="upgrade-icon">${u.icon}</div>
      <div class="upgrade-name">${u.name}</div>
      <div class="upgrade-desc">${u.desc}</div>
      <span class="upgrade-rarity rarity-${u.rarity}">${u.rarity}</span>
    `;
    card.onclick = () => {
      u.apply(player);
      document.getElementById('levelupScreen').classList.add('hidden');
      document.getElementById('hud').classList.remove('hidden');
      state = 'playing';
      lastFrame = performance.now(); // prevent dt spike
      spawnFloatText(player.x, player.y - 50, u.name + '!', '#c084fc');
    };
    container.appendChild(card);
  });
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('levelupScreen').classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPAWNING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let shakeTime = 0, shakeMag = 0;
function screenShake(dur) { shakeTime = dur; shakeMag = 6; }

function spawnEnemies(dt) {
  lastSpawn += dt;
  // Scale difficulty
  spawnInterval = Math.max(0.4, 2.0 - elapsed * 0.015);
  const danger = Math.floor(elapsed / 30); // increases every 30s

  if (lastSpawn < spawnInterval) return;
  lastSpawn = 0;

  const count = 1 + Math.floor(danger * 0.5) + Math.floor(Math.random() * 2);
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r = 500 + Math.random() * 200;
    const typeIdx = Math.min(Math.floor(Math.random() * (1 + danger)), ENEMY_TYPES.length - 1);
    const t = ENEMY_TYPES[typeIdx];
    const scale = 1 + danger * 0.1;
    enemies.push({
      x: player.x + Math.cos(angle) * r,
      y: player.y + Math.sin(angle) * r,
      hp: t.hp * scale, maxHp: t.hp * scale,
      speed: t.speed, xp: t.xp, dmg: t.dmg,
      name: t.name,
      emoji: t.emoji, spriteKey: t.spriteKey,
      color: t.color, size: t.size, boss: false,
    });
  }

  // Boss at 60s intervals
  if (elapsed > 30 && elapsed - lastBossTime >= 60) {
    lastBossTime = elapsed;
    const angle = Math.random() * Math.PI * 2;
    const b = BOSS_TYPES[Math.floor(Math.random() * BOSS_TYPES.length)];
    const bossScale = 1 + Math.floor(elapsed / 60) * 0.3;
    enemies.push({
      x: player.x + Math.cos(angle) * 600,
      y: player.y + Math.sin(angle) * 600,
      hp: b.hp * bossScale, maxHp: b.hp * bossScale,
      speed: b.speed, xp: b.xp, dmg: b.dmg,
      name: b.name,
      emoji: b.emoji, spriteKey: b.spriteKey,
      color: b.color, size: b.size, boss: true,
    });
    spawnFloatText(player.x, player.y - 80, 'âš  BOSS INCOMING!', '#ff9900');
    playSFX('boss');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARTICLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawnHitParticles(x, y, color) {
  for (let i = 0; i < 4; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 50 + Math.random() * 80;
    particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 0.4, color, size: 3 });
  }
}
function spawnDeathParticles(x, y, color) {
  for (let i = 0; i < 10; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 80 + Math.random() * 120;
    particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 0.7, color, size: 4 + Math.random()*3 });
  }
}
function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.vx *= 0.9; p.vy *= 0.9;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function spawnFloatText(x, y, text, color) {
  floatTexts.push({ x, y, text, color, life: 1.0 });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HUD UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateHUD() {
  const hpPct = Math.max(0, player.hp / player.maxHp * 100);
  document.getElementById('hpFill').style.width = hpPct + '%';
  document.getElementById('hpText').textContent = Math.max(0, Math.floor(player.hp)) + '/' + Math.floor(player.maxHp);
  const xpPct = player.xp / xpToNext * 100;
  document.getElementById('xpFill').style.width = xpPct + '%';
  document.getElementById('levelBadge').textContent = 'Level ' + player.level;
  document.getElementById('killCounter').textContent = 'ğŸ’€ ' + kills;
  const mins = Math.floor(elapsed / 60).toString().padStart(2,'0');
  const secs = Math.floor(elapsed % 60).toString().padStart(2,'0');
  document.getElementById('timerBox').textContent = mins + ':' + secs;
  // Energy
  const ePct = (player.energy / player.maxEnergy) * 100;
  const fill = document.getElementById('energyFill');
  fill.style.width = ePct + '%';
  fill.className = 'energy-fill' + (player.superReady ? ' charged' : '');
  document.getElementById('energyText').textContent = Math.floor(player.energy) + '/100';
  const hint = document.getElementById('superHint');
  hint.textContent = 'âš¡ SPACE â€” ' + (selectedChar ? selectedChar.ultimate.name : 'SUPERMOVE') + '!';
  hint.className = 'super-hint' + (player.superReady ? ' visible' : '');
  // Supermove cooldown
  if (player.superCD > 0) player.superCD -= 1/60;
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TREE_POSITIONS = [];
for (let i = 0; i < 300; i++) {
  TREE_POSITIONS.push({ x: (Math.random()-0.5)*4000, y: (Math.random()-0.5)*4000, scale: 0.7 + Math.random()*0.6 });
}
const STARS = [];
for (let i = 0; i < 150; i++) {
  STARS.push({ x: Math.random()*2000, y: Math.random()*1200, size: 1 + Math.random()*2 });
}

function render() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // Screen shake
  let sx = 0, sy = 0;
  if (shakeTime > 0) {
    shakeTime -= 1/60;
    sx = (Math.random()-0.5) * shakeMag;
    sy = (Math.random()-0.5) * shakeMag;
  }

  ctx.save();
  ctx.translate(sx, sy);

  // Background
  const grad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W*0.8);
  grad.addColorStop(0, '#0f1020');
  grad.addColorStop(1, '#060810');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars (fixed to screen, parallax feel)
  ctx.save();
  const starOffX = camera.x * 0.02 % 2000;
  const starOffY = camera.y * 0.02 % 1200;
  STARS.forEach(s => {
    const sx2 = ((s.x - starOffX) % W + W) % W;
    const sy2 = ((s.y - starOffY) % H + H) % H;
    ctx.fillStyle = `rgba(255,255,255,${0.2 + Math.random()*0.1})`;
    ctx.beginPath();
    ctx.arc(sx2, sy2, s.size * 0.5, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.restore();

  // World transform
  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  // Ground tiles
  const tileSize = 80;
  const startX = Math.floor(camera.x / tileSize) * tileSize;
  const startY = Math.floor(camera.y / tileSize) * tileSize;
  for (let tx = startX; tx < camera.x + W + tileSize; tx += tileSize) {
    for (let ty = startY; ty < camera.y + H + tileSize; ty += tileSize) {
      const shade = ((Math.floor(tx/tileSize) + Math.floor(ty/tileSize)) % 2 === 0) ? '0a0f18' : '0c1220';
      ctx.fillStyle = '#' + shade;
      ctx.fillRect(tx, ty, tileSize, tileSize);
    }
  }

  // Trees (decorative)
  TREE_POSITIONS.forEach(t => {
    const screenX = t.x - camera.x;
    const screenY = t.y - camera.y;
    if (screenX < -60 || screenX > W+60 || screenY < -60 || screenY > H+60) return;
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.scale(t.scale, t.scale);
    ctx.font = '32px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.globalAlpha = 0.5;
    ctx.fillText('ğŸŒ²', 0, 0);
    ctx.restore();
  });

  // XP Gems
  ctx.font = '12px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  xpGems.forEach(g => {
    ctx.fillStyle = '#a855f7';
    ctx.shadowColor = '#c084fc';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(g.x, g.y, 5, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.shadowBlur = 0;

  // Energy Orbs (cyan diamond shape)
  energyOrbs.forEach(o => {
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = '#06b6d4';
    ctx.shadowColor = '#a5f3fc';
    ctx.shadowBlur = 10;
    const s = 5;
    ctx.fillRect(-s, -s, s*2, s*2);
    ctx.shadowBlur = 0;
    ctx.restore();
  });

  // Gold Coins (spinning star effect)
  goldCoins.forEach(c => {
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.fillStyle = '#fbbf24';
    ctx.shadowColor = '#fde68a';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(0, 0, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#fde68a';
    ctx.beginPath();
    ctx.arc(0, 0, 2.5, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Enemies
  enemies.forEach(e => {
    const isInv = e.poisoned > 0;
    ctx.save();
    ctx.translate(e.x, e.y);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(0, e.size*0.6, e.size*0.7, e.size*0.25, 0, 0, Math.PI*2);
    ctx.fill();

    // HP bar for bosses
    if (e.boss) {
      const bw = e.size * 3;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(-bw/2, -e.size - 12, bw, 6);
      ctx.fillStyle = '#ff9900';
      ctx.fillRect(-bw/2, -e.size - 12, bw * (e.hp / e.maxHp), 6);
    }

    // Flash green if poisoned
    if (isInv) ctx.globalAlpha = 0.6;
    drawEntity(e.emoji, e.spriteKey || e.emoji, e.size, 1, isInv);

    ctx.globalAlpha = 1;
    ctx.restore();

    // HP bar (small, non-boss)
    if (!e.boss && e.hp < e.maxHp) {
      const bw = e.size * 2;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(e.x - bw/2, e.y - e.size - 8, bw, 4);
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(e.x - bw/2, e.y - e.size - 8, bw * (e.hp / e.maxHp), 4);
    }
  });

  // Projectiles
  projectiles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 12;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  });

  // Player
  ctx.save();
  ctx.translate(player.x, player.y);

  // Player shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(0, player.size*0.65, player.size*0.7, player.size*0.25, 0, 0, Math.PI*2);
  ctx.fill();

  // Aura
  if (player.invTime > 0) {
    ctx.globalAlpha = 0.4 + Math.sin(elapsed*20)*0.3;
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(0, 0, player.size * 1.5, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  ctx.shadowColor = player.color;
  ctx.shadowBlur = 20;
  // Use sprite animator if available, else fall back to drawEntity (sprite/emoji)
  if (player.animator) {
    const drawn = player.animator.draw(ctx, player.size);
    if (!drawn) drawEntity(player.emoji, selectedChar ? selectedChar.id : player.emoji, player.size);
  } else {
    drawEntity(player.emoji, selectedChar ? selectedChar.id : player.emoji, player.size);
  }
  ctx.shadowBlur = 0;
  ctx.restore();

  ctx.restore(); // world transform

  // Float texts (screen space)
  const now = performance.now();
  for (let i = floatTexts.length - 1; i >= 0; i--) {
    const ft = floatTexts[i];
    ft.life -= 1/60;
    if (ft.life <= 0) { floatTexts.splice(i, 1); continue; }
    const sx2 = ft.x - camera.x + sx;
    const sy2 = ft.y - camera.y - (1 - ft.life) * 50 + sy;
    ctx.globalAlpha = ft.life;
    ctx.fillStyle = ft.color;
    ctx.font = 'bold 14px Nunito, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(ft.text, sx2, sy2);
  }
  ctx.globalAlpha = 1;

  ctx.restore(); // shake
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME OVER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function endGame() {
  state = 'gameover';
  stopMusic();
  playSFX('gameover');
  document.getElementById('bossHPBar').style.display = 'none';

  totalRuns++;
  const isNewBest = elapsed > bestTime;
  if (isNewBest) bestTime = elapsed;

  saveGame();

  const mins = Math.floor(elapsed / 60).toString().padStart(2,'0');
  const secs = Math.floor(elapsed % 60).toString().padStart(2,'0');
  const bm   = Math.floor(bestTime/60).toString().padStart(2,'0');
  const bs   = Math.floor(bestTime%60).toString().padStart(2,'0');

  document.getElementById('gameoverStats').innerHTML = `
    Survived <span>${mins}:${secs}</span><br>
    Enemies defeated <span>${kills}</span><br>
    Level reached <span>${player.level}</span><br>
    Wave reached <span>${waveNumber}</span><br>
    Gold earned this run <span>ğŸª™ ${runGold}</span><br>
    Total gold <span>ğŸª™ ${gold}</span><br>
    Raider <span>${selectedChar.emoji} ${selectedChar.name}</span>
  `;
  const bestEl = document.getElementById('gameoverBest');
  if (isNewBest && elapsed > 10) {
    bestEl.textContent = 'ğŸ† New Best Time! ' + bm + ':' + bs;
  } else if (bestTime > 0) {
    bestEl.textContent = 'ğŸ† Best: ' + bm + ':' + bs + ' â€” Run #' + totalRuns;
  } else {
    bestEl.textContent = '';
  }
  showScreen('gameoverScreen');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PAUSE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function togglePause() {
  if (state === 'playing') {
    state = 'paused';
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('pauseScreen').classList.remove('hidden');
  } else if (state === 'paused') {
    resumeGame();
  }
}

function resumeGame() {
  state = 'playing';
  lastFrame = performance.now();
  gameStartTime += performance.now() - lastFrame; // prevent time warp
  document.getElementById('pauseScreen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openTown(fromState) {
  prevState = fromState;
  buildTownScreen();
  showScreen('townScreen');
  state = 'town';
}

function leaveTown() {
  if (prevState === 'playing' || prevState === 'paused') {
    state = 'playing';
    lastFrame = performance.now();
    showScreen('hud');
  } else {
    // came from gameover / menu
    state = 'select';
    buildCharSelect();
    showScreen('selectScreen');
  }
}

function buildTownScreen() {
  document.getElementById('townGoldDisplay').textContent = 'ğŸª™ ' + gold + ' gold';
  const grid = document.getElementById('townGrid');
  grid.innerHTML = '';
  TOWN_UPGRADES.forEach(u => {
    const rank = townUpgrades[u.id] || 0;
    const maxed = rank >= u.maxRank;
    const cost = u.cost + rank * Math.floor(u.cost * 0.5);
    const canAfford = gold >= cost;
    const card = document.createElement('div');
    card.className = 'town-card' + (maxed ? ' maxed' : (!canAfford ? ' cant-afford' : ''));
    card.innerHTML = `
      <div class="town-level">${rank}/${u.maxRank}</div>
      <div class="town-icon">${u.icon}</div>
      <div class="town-name">${u.name}</div>
      <div class="town-desc">${u.desc}</div>
      ${maxed
        ? '<div class="town-maxed-label">âœ“ Maxed Out</div>'
        : `<div class="town-cost">${canAfford ? 'ğŸª™' : 'ğŸ”’'} ${cost} gold</div>`
      }
    `;
    if (!maxed && canAfford) {
      card.onclick = () => {
        gold -= cost;
        townUpgrades[u.id] = rank + 1;
        playSFX('levelup');
        saveGame();
        buildTownScreen();
      };
    }
    grid.appendChild(card);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INPUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', e => {
  if (!keys[e.key]) justPressed[e.key] = true;
  keys[e.key] = true;
  if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'ArrowDown') e.preventDefault();
  // M = toggle music/mute (works on title screen and in-game)
  if (e.key === 'm' || e.key === 'M') {
    initAudio();
    if (state === 'title') {
      // First M press starts title music; subsequent presses toggle mute
      if (!titleMusic) {
        startTitleMusic();
        muted = false;
      } else {
        setMute(!muted);
      }
    } else {
      setMute(!muted);
    }
    return;
  }

  // Title screen â€” SPACE only
  if (state === 'title' && e.key === ' ') { leaveTitleScreen(); return; }
  // Pause toggle
  if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
    if (state === 'playing' || state === 'paused') togglePause();
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('load', () => {
  canvas = document.getElementById('gameCanvas');
  ctx    = canvas.getContext('2d');

  // Touch movement
  let touchId = null, touchStartX = 0, touchStartY = 0;
  canvas.addEventListener('touchstart', e => {
    const t = e.changedTouches[0];
    touchId = t.identifier; touchStartX = t.clientX; touchStartY = t.clientY;
  }, {passive: true});
  canvas.addEventListener('touchmove', e => {
    for (const t of e.changedTouches) {
      if (t.identifier !== touchId) continue;
      const dx = t.clientX - touchStartX, dy = t.clientY - touchStartY;
      const thr = 10;
      keys['a'] = dx < -thr; keys['d'] = dx > thr;
      keys['w'] = dy < -thr; keys['s'] = dy > thr;
    }
  }, {passive: true});
  canvas.addEventListener('touchend', () => {
    keys['a'] = keys['d'] = keys['w'] = keys['s'] = false;
  }, {passive: true});

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (titleCanvas) {
      titleCanvas.width  = window.innerWidth;
      titleCanvas.height = window.innerHeight;
    }
  }
  resize();
  window.addEventListener('resize', resize);

  // Title screen: click or tap to proceed
  // Title screen advances on SPACE only (handled in keydown above)

  // Preload all sprites (including titleBg) before showing title
  loadSprites();

  // Show title screen (slight delay so titleBg image has a chance to load)
  setTimeout(() => showTitleScreen(), 100);

  // Mute
  document.getElementById('muteBtn').onclick = () => setMute(!muted);

  // Start / Retry
  document.getElementById('startBtn').onclick = () => {
    initAudio(); showScreen(null); startGame();
  };
  document.getElementById('retryBtn').onclick = () => {
    showScreen(null); startGame();
  };

  // Gameover â†’ Town
  document.getElementById('visitTownBtn').onclick = () => {
    initAudio(); openTown('gameover');
  };

  // Gameover â†’ Main Menu
  document.getElementById('menuBtn').onclick = () => {
    stopMusic(); state = 'select'; buildCharSelect();
    showScreen('selectScreen');
    document.getElementById('startBtn').disabled = true;
    selectedChar = null;
    document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected'));
  };

  // Pause buttons
  document.getElementById('pauseResume').onclick = () => resumeGame();
  document.getElementById('pauseTown').onclick   = () => { initAudio(); openTown('paused'); };
  document.getElementById('pauseRetry').onclick  = () => { showScreen(null); startGame(); };
  document.getElementById('pauseMenu').onclick   = () => {
    stopMusic(); stopTitleMusic(); state = 'select'; buildCharSelect();
    showScreen('selectScreen');
    document.getElementById('startBtn').disabled = !selectedChar;
  };

  // Town leave
  document.getElementById('townLeaveBtn').onclick = () => leaveTown();
});
</script>
</body>
</html>
