<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laurie~ Saves the World (From Trixie)</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; font-family: 'Courier New', monospace; }
  #gameContainer { position: relative; width: 800px; }
  #gameCanvas { display: block; image-rendering: pixelated; }
  #hudCanvas { display: block; image-rendering: pixelated; }
  #overlay { position: absolute; top: 0; left: 0; width: 800px; height: 480px; pointer-events: none; }
  #quipBox {
    position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.85); border: 2px solid #ff6600; color: #ff6600;
    padding: 8px 18px; font-size: 15px; font-weight: bold; font-family: 'Courier New', monospace;
    display: none; white-space: nowrap; z-index: 10; text-shadow: 0 0 8px #ff6600;
    pointer-events: none;
  }
  #titleScreen {
    position: absolute; top: 0; left: 0; width: 800px; height: 600px;
    background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; color: #fff;
  }
  #titleScreen h1 { font-size: 28px; color: #ff6600; text-shadow: 0 0 16px #ff6600; margin-bottom: 8px; }
  #titleScreen h2 { font-size: 16px; color: #aaa; margin-bottom: 30px; }
  #titleScreen p { color: #888; font-size: 13px; margin: 3px 0; }
  #startBtn {
    margin-top: 25px; padding: 12px 40px; background: #ff6600; color: #000;
    border: none; font-size: 18px; font-family: 'Courier New', monospace;
    font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
  }
  #startBtn:hover { background: #ffaa00; }
  #winScreen {
    position: absolute; top: 0; left: 0; width: 800px; height: 600px;
    background: rgba(0,0,0,0.95); display: none; flex-direction: column;
    align-items: center; justify-content: center; z-index: 200;
  }
  #winScreen h1 { font-size: 30px; color: #ff6600; text-shadow: 0 0 20px #ff6600; }
  #winScreen p { color: #aaa; margin: 10px 0; font-size: 16px; }
  #gameoverScreen {
    position: absolute; top: 0; left: 0; width: 800px; height: 600px;
    background: rgba(0,0,0,0.95); display: none; flex-direction: column;
    align-items: center; justify-content: center; z-index: 200;
  }
  #gameoverScreen h1 { font-size: 50px; color: #ff0000; text-shadow: 0 0 20px #ff0000; }
  #gameoverScreen p { color: #aaa; margin: 10px 0; }
  #restartBtn, #restartBtn2 {
    margin-top: 20px; padding: 10px 30px; background: #cc0000; color: #fff;
    border: none; font-size: 16px; font-family: 'Courier New', monospace;
    font-weight: bold; cursor: pointer;
  }
  #controls { color: #555; font-size: 11px; margin-top: 10px; text-align: center; }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="480"></canvas>
  <canvas id="hudCanvas" width="800" height="120"></canvas>
  <div id="overlay">
    <div id="quipBox"></div>
  </div>
  <div id="titleScreen">
    <h1>‚òï LAURIE~ SAVES THE WORLD ‚òï</h1>
    <h2>(From Trixie)</h2>
    <p style="color:#ff6600;font-size:14px;margin-bottom:15px;">A Hyper-Caffeinated Retro FPS</p>
    <p>üéÆ WASD / Arrow Keys ‚Äî Move &amp; Strafe</p>
    <p>üñ±Ô∏è Left Mouse / Space ‚Äî Coffee Spit (Primary)</p>
    <p>üçû G ‚Äî Baguette Bomb</p>
    <p>‚ö° E ‚Äî Gojira Go! (when charged)</p>
    <p>üîÑ Q ‚Äî Strafe Left &nbsp;&nbsp; R ‚Äî Strafe Right</p>
    <button id="startBtn" onclick="startGame()">BREW UP &amp; PLAY</button>
    <div id="controls" style="color:#555;margin-top:15px;">Defeat Trixie. Save the world. Get coffee.</div>
  </div>
  <div id="winScreen" style="display:none;flex-direction:column">
    <h1>‚òï WORLD SAVED ‚òï</h1>
    <p style="color:#ff6600;font-size:20px;margin-top:15px;">"You're still dead to me."</p>
    <p style="color:#888;margin-top:20px;">‚Äî Laurie~</p>
    <button id="restartBtn2" onclick="location.reload()" style="margin-top:30px">PLAY AGAIN</button>
  </div>
  <div id="gameoverScreen">
    <h1>GAME OVER</h1>
    <p style="color:#ff6600;">Trixie's prickles were too much...</p>
    <button id="restartBtn" onclick="location.reload()">TRY AGAIN</button>
  </div>
</div>

<script>
// ============================================================
// LAURIE~ SAVES THE WORLD (FROM TRIXIE) ‚Äî Full HTML5 Game
// Raycasting Engine + Doom HUD + Enemies + Boss + Dialogue
// ============================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hudCanvas = document.getElementById('hudCanvas');
const hud = hudCanvas.getContext('2d');
const W = 800, H = 480, HUD_H = 120;
const HALF_H = H / 2;

let gameRunning = false;
let gameWon = false;
let gameDead = false;

// ‚îÄ‚îÄ MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0=empty, 1=wall, 2=coffee-door(locked), 3=exit
const MAP_W = 24, MAP_H = 24;
const MAP = [
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,1,1,1,0,0,0,1,1,0,0,1,1,0,0,0,1,1,1,0,1,
  1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,
  1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,
  1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,
  1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1,
  1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,
  1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
  1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
];

function mapAt(mx, my) {
  if (mx < 0 || mx >= MAP_W || my < 0 || my >= MAP_H) return 1;
  return MAP[Math.floor(my) * MAP_W + Math.floor(mx)];
}

// ‚îÄ‚îÄ PLAYER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const player = {
  x: 2.5, y: 2.5, angle: 0,
  speed: 0.05, rotSpeed: 0.045,
  health: 100, armor: 50,
  grenades: 5,
  energy: 0,        // 0‚Äì100
  hasKey: false,
  fov: Math.PI / 2.8,
  moveForward: 0, moveBack: 0, rotLeft: 0, rotRight: 0,
  strafeLeft: 0, strafeRight: 0,
  shooting: false, shootTimer: 0,
  grenadeTimer: 0,
  invincible: 0,
  score: 0,
};

// ‚îÄ‚îÄ PICKUPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const pickups = [
  { x: 5.5, y: 5.5, type: 'health', alive: true },
  { x: 10.5, y: 3.5, type: 'grenade', alive: true },
  { x: 15.5, y: 5.5, type: 'armor', alive: true },
  { x: 3.5, y: 15.5, type: 'key', alive: true },
  { x: 12.5, y: 12.5, type: 'health', alive: true },
  { x: 18.5, y: 10.5, type: 'grenade', alive: true },
  { x: 20.5, y: 3.5, type: 'health', alive: true },
  { x: 20.5, y: 20.5, type: 'armor', alive: true },
  { x: 7.5, y: 18.5, type: 'health', alive: true },
  { x: 14.5, y: 21.5, type: 'grenade', alive: true },
];

// ‚îÄ‚îÄ ENEMIES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function makeEnemy(x, y, type) {
  return {
    x, y, type,
    health: type === 'boss' ? 600 : type === 'spitter' ? 50 : 30,
    maxHealth: type === 'boss' ? 600 : type === 'spitter' ? 50 : 30,
    alive: true,
    state: 'idle',   // idle / chase / attack / hurt / dead
    angle: 0,
    shootTimer: Math.random() * 60,
    moveTimer: 0,
    phase: 1,        // boss phases
    dist: 999,
    screenX: -1,
    size: type === 'boss' ? 1.2 : 0.6,
    spawnTimer: 0,
  };
}

let enemies = [
  makeEnemy(5.5, 8.5, 'melee'),
  makeEnemy(8.5, 5.5, 'spitter'),
  makeEnemy(15.5, 3.5, 'melee'),
  makeEnemy(12.5, 6.5, 'spitter'),
  makeEnemy(18.5, 5.5, 'melee'),
  makeEnemy(20.5, 8.5, 'spitter'),
  makeEnemy(16.5, 15.5, 'melee'),
  makeEnemy(10.5, 18.5, 'spitter'),
  makeEnemy(5.5, 20.5, 'melee'),
  makeEnemy(20.5, 16.5, 'spitter'),
  makeEnemy(21.5, 21.5, 'boss'),  // TRIXIE ‚Äì Final Room
];
const BOSS = enemies[enemies.length - 1];

// ‚îÄ‚îÄ PROJECTILES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let projectiles = []; // { x,y,dx,dy,type,owner,alive,ttl }
let explosions = [];  // { x,y,r,alpha }
let gojiraActive = false, gojiraTimer = 0;

// ‚îÄ‚îÄ QUIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const trixieQuips = [
  "You wouldn't like me when I'm angry!",
  "Damn you, Huntress!",
  "Embrace the prickle, Laurie!",
  "Your coffee means NOTHING to me!",
  "I am TRIXIE. I am the CACTUS!",
  "Your baguette can't hurt my thorns!",
];
const laurieQuips_kill  = ["Needs more brew.", "That's a latte damage.", "Espresso yourself!", "Stay down, prickles."];
const laurieQuips_bomb  = ["Let's get this bread.", "Gluten-free? Nope.", "Freshly baked destruction!"];
const laurieQuips_gojira = ["Time for a monster mash!", "GOJIRA GO!!!", "Kaiju delivery, special order!"];

let quipTimer = 0;
const quipBox = document.getElementById('quipBox');
function showQuip(text, color) {
  quipBox.style.display = 'block';
  quipBox.style.color = color || '#ff6600';
  quipBox.style.borderColor = color || '#ff6600';
  quipBox.textContent = text;
  quipTimer = 180;
}

// ‚îÄ‚îÄ KEYS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (!gameRunning) return;
  if (e.code === 'KeyG') throwGrenade();
  if (e.code === 'KeyE') activateGojira();
  e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
canvas.addEventListener('mousedown', e => { if (gameRunning) player.shooting = true; });
canvas.addEventListener('mouseup', e => { player.shooting = false; });

function startGame() {
  document.getElementById('titleScreen').style.display = 'none';
  gameRunning = true;
  loop();
}

// ‚îÄ‚îÄ RAYCASTING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const NUM_RAYS = 400;
const PROJ_DIST = W / (2 * Math.tan(player.fov / 2));
const zBuffer = new Float32Array(W);

function castRays() {
  // Sky (desert haze)
  const skyGrad = ctx.createLinearGradient(0, 0, 0, HALF_H);
  skyGrad.addColorStop(0, '#1a0a00');
  skyGrad.addColorStop(1, '#4a2000');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, HALF_H);

  // Ground (sandy)
  const gndGrad = ctx.createLinearGradient(0, HALF_H, 0, H);
  gndGrad.addColorStop(0, '#3d2800');
  gndGrad.addColorStop(1, '#1a1000');
  ctx.fillStyle = gndGrad;
  ctx.fillRect(0, HALF_H, W, HALF_H);

  const sliceW = W / NUM_RAYS;
  for (let i = 0; i < NUM_RAYS; i++) {
    const rayAngle = player.angle - player.fov / 2 + (i / NUM_RAYS) * player.fov;
    const { dist, side } = castSingleRay(rayAngle);
    zBuffer[i] = dist;
    const wallH = Math.min(H, PROJ_DIST / dist);
    const top = HALF_H - wallH / 2;

    // Wall color ‚Äî side walls darker
    const bright = Math.max(30, 255 - dist * 18);
    let r, g, b;
    if (side === 2) { // door
      r = Math.floor(bright * 0.6); g = Math.floor(bright * 0.4); b = 0;
    } else if (side === 1) { // NS wall
      r = Math.floor(bright * 0.5); g = Math.floor(bright * 0.3); b = Math.floor(bright * 0.1);
    } else { // EW wall darker
      r = Math.floor(bright * 0.35); g = Math.floor(bright * 0.2); b = Math.floor(bright * 0.05);
    }
    // Pixel-dither pattern for 8-bit feel
    const dither = ((i % 3) + (Math.floor(top) % 3)) % 3 === 0 ? 10 : 0;
    ctx.fillStyle = `rgb(${r+dither},${g+dither},${b+dither})`;
    ctx.fillRect(Math.floor(i * sliceW), Math.floor(top), Math.ceil(sliceW) + 1, Math.ceil(wallH));
  }
}

function castSingleRay(angle) {
  let rx = player.x, ry = player.y;
  const dx = Math.cos(angle), dy = Math.sin(angle);
  const stepSize = 0.02;
  let dist = 0;
  let side = 0;
  while (dist < 25) {
    dist += stepSize;
    const nx = rx + dx * dist, ny = ry + dy * dist;
    const tile = mapAt(nx, ny);
    if (tile === 1) { side = (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) ? 0 : 1; return { dist, side }; }
    if (tile === 2) { return { dist, side: 2 }; } // door
  }
  return { dist: 25, side: 0 };
}

// ‚îÄ‚îÄ SPRITE RENDERING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawSprites() {
  const allObjs = [
    ...enemies.filter(e => e.alive),
    ...pickups.filter(p => p.alive),
    ...projectiles.filter(p => p.alive && p.owner === 'enemy'),
  ];
  // Sort by distance descending
  allObjs.forEach(obj => {
    const dx = obj.x - player.x, dy = obj.y - player.y;
    obj.dist = Math.sqrt(dx*dx + dy*dy);
    const angle = Math.atan2(dy, dx) - player.angle;
    let a = angle;
    while (a > Math.PI) a -= 2*Math.PI;
    while (a < -Math.PI) a += 2*Math.PI;
    obj.screenX = (0.5 + a / player.fov) * W;
  });
  allObjs.sort((a, b) => b.dist - a.dist);
  allObjs.forEach(obj => drawSprite(obj));
}

function drawSprite(obj) {
  const dist = obj.dist;
  if (dist < 0.3) return;
  const size = obj.size !== undefined ? obj.size : 0.5;
  const spriteH = Math.min(H * 1.5, PROJ_DIST * size / dist);
  const spriteW = spriteH;
  const sx = obj.screenX - spriteW / 2;
  const sy = HALF_H - spriteH / 2;

  // Only draw if in FOV
  if (obj.screenX < -spriteW || obj.screenX > W + spriteW) return;

  // Check z-buffer (simple: use center column)
  const centerCol = Math.floor(obj.screenX / (W / NUM_RAYS));
  if (centerCol >= 0 && centerCol < NUM_RAYS && zBuffer[centerCol] < dist) return;

  ctx.save();
  ctx.globalAlpha = Math.min(1, 1 - (dist - 0.3) * 0.02);

  if (obj.type === 'boss') {
    drawBossSprite(sx, sy, spriteW, spriteH, obj);
  } else if (obj.type === 'melee' || obj.type === 'spitter') {
    drawEnemySprite(sx, sy, spriteW, spriteH, obj);
  } else if (obj.type === 'health') {
    drawPickupSprite(sx, sy, spriteW * 0.6, spriteH * 0.6, '#00ff88', '‚ù§Ô∏è', obj);
  } else if (obj.type === 'grenade') {
    drawPickupSprite(sx, sy, spriteW * 0.6, spriteH * 0.6, '#aaaa00', 'ü•ñ', obj);
  } else if (obj.type === 'armor') {
    drawPickupSprite(sx, sy, spriteW * 0.6, spriteH * 0.6, '#4488ff', 'üõ°Ô∏è', obj);
  } else if (obj.type === 'key') {
    drawPickupSprite(sx, sy, spriteW * 0.6, spriteH * 0.6, '#ffdd00', '‚òï', obj);
  } else if (obj.type === 'needle') {
    ctx.fillStyle = '#88ff44';
    ctx.fillRect(sx + spriteW*0.4, sy + spriteH*0.4, spriteW * 0.2, spriteH * 0.2);
  }
  ctx.restore();
}

function drawEnemySprite(sx, sy, sw, sh, e) {
  const px = Math.floor(sx), py = Math.floor(sy), pw = Math.ceil(sw), ph = Math.ceil(sh);
  // Body - cactus green blocky
  const phaseColor = e.state === 'hurt' ? '#ff8800' : '#2d7a2d';
  ctx.fillStyle = phaseColor;
  ctx.fillRect(px + pw*0.3, py + ph*0.15, pw*0.4, ph*0.7);  // trunk
  ctx.fillRect(px + pw*0.15, py + ph*0.25, pw*0.25, ph*0.3); // left arm
  ctx.fillRect(px + pw*0.6, py + ph*0.25, pw*0.25, ph*0.3);  // right arm
  // Head
  ctx.fillStyle = '#1a4d1a';
  ctx.fillRect(px + pw*0.3, py + ph*0.02, pw*0.4, ph*0.15);
  // Eyes
  ctx.fillStyle = '#ff2200';
  ctx.fillRect(px + pw*0.38, py + ph*0.05, pw*0.08, ph*0.06);
  ctx.fillRect(px + pw*0.54, py + ph*0.05, pw*0.08, ph*0.06);
  // Spines
  ctx.fillStyle = '#aaff44';
  for (let i = 0; i < 5; i++) {
    ctx.fillRect(px + pw*(0.25 + i*0.12), py + ph*0.1, 2, ph*0.12);
  }
  // Health bar
  if (e.health < e.maxHealth) {
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(px, py - 6, pw, 4);
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(px, py - 6, pw * (e.health / e.maxHealth), 4);
  }
}

function drawBossSprite(sx, sy, sw, sh, e) {
  const px = Math.floor(sx), py = Math.floor(sy), pw = Math.ceil(sw), ph = Math.ceil(sh);
  const col = e.state === 'hurt' ? '#ff4400' : (e.phase >= 2 ? '#1a6600' : '#3a9900');
  // Giant cactus body
  ctx.fillStyle = col;
  ctx.fillRect(px + pw*0.2, py + ph*0.1, pw*0.6, ph*0.85);
  // Arms
  ctx.fillRect(px + pw*0.0, py + ph*0.2, pw*0.22, ph*0.35);
  ctx.fillRect(px + pw*0.78, py + ph*0.2, pw*0.22, ph*0.35);
  // Arm tips (up)
  ctx.fillRect(px + pw*0.0, py + ph*0.1, pw*0.12, ph*0.15);
  ctx.fillRect(px + pw*0.88, py + ph*0.1, pw*0.12, ph*0.15);
  // Head/Face
  ctx.fillStyle = '#1a4d00';
  ctx.fillRect(px + pw*0.25, py, pw*0.5, ph*0.15);
  // Angry eyes
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(px + pw*0.32, py + ph*0.03, pw*0.12, ph*0.07);
  ctx.fillRect(px + pw*0.56, py + ph*0.03, pw*0.12, ph*0.07);
  // Spines (many)
  ctx.fillStyle = '#ddff00';
  for (let i = 0; i < 8; i++) {
    ctx.fillRect(px + pw*(0.18 + i*0.09), py + ph*0.08, 3, ph*0.2);
  }
  // Crown of spines
  for (let i = 0; i < 5; i++) {
    ctx.fillRect(px + pw*(0.25 + i*0.12), py - ph*0.08, 3, ph*0.1);
  }
  // Phase 2: vines
  if (e.phase >= 2) {
    ctx.strokeStyle = '#005500';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(px, py + ph*0.5);
    ctx.bezierCurveTo(px-20, py+ph*0.3, px-30, py+ph*0.7, px-10, py+ph*0.9);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px+pw, py + ph*0.5);
    ctx.bezierCurveTo(px+pw+20, py+ph*0.3, px+pw+30, py+ph*0.7, px+pw+10, py+ph*0.9);
    ctx.stroke();
  }
  // Health bar
  ctx.fillStyle = '#000';
  ctx.fillRect(px, py - 12, pw, 8);
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(px, py - 12, pw, 8);
  ctx.fillStyle = '#00ff44';
  ctx.fillRect(px, py - 12, pw * (e.health / e.maxHealth), 8);
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.min(12, pw*0.12)}px Courier New`;
  ctx.fillText('TRIXIE', px + pw*0.3, py - 3);
}

function drawPickupSprite(sx, sy, sw, sh, color, emoji, obj) {
  const bob = Math.sin(Date.now() * 0.004) * 3;
  ctx.font = `${Math.ceil(sh * 0.6)}px serif`;
  ctx.fillText(emoji, sx + sw*0.1, sy + sh*0.7 + bob);
}

// ‚îÄ‚îÄ HUD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawHUD() {
  hud.fillStyle = '#1a0a00';
  hud.fillRect(0, 0, W, HUD_H);
  // Border
  hud.strokeStyle = '#ff6600';
  hud.lineWidth = 2;
  hud.strokeRect(1, 1, W - 2, HUD_H - 2);

  // HEALTH
  hud.fillStyle = '#ff2200';
  hud.font = 'bold 11px Courier New';
  hud.fillText('HEALTH', 15, 18);
  drawBar(hud, 15, 24, 120, 18, player.health, 100, '#ff2200', '#440000');
  hud.fillStyle = '#fff';
  hud.font = 'bold 18px Courier New';
  hud.fillText(Math.max(0, player.health) + '%', 15, 60);

  // ARMOR
  hud.fillStyle = '#4488ff';
  hud.font = 'bold 11px Courier New';
  hud.fillText('ARMOR', 155, 18);
  drawBar(hud, 155, 24, 120, 18, player.armor, 100, '#4488ff', '#001144');
  hud.fillStyle = '#fff';
  hud.font = 'bold 18px Courier New';
  hud.fillText(Math.max(0, player.armor) + '%', 155, 60);

  // GRENADES
  hud.fillStyle = '#aaaa00';
  hud.font = 'bold 11px Courier New';
  hud.fillText('BAGUETTES', 295, 18);
  hud.fillStyle = '#fff';
  hud.font = 'bold 28px Courier New';
  hud.fillText('ü•ñ x' + player.grenades, 295, 55);

  // LAURIE FACE (center portrait)
  drawFace(hud, 375, 10, 100, 100);

  // GOJIRA ENERGY
  const gReady = player.energy >= 100;
  hud.fillStyle = gReady ? '#ffff00' : '#ff6600';
  hud.font = 'bold 11px Courier New';
  hud.fillText('GOJIRA GO!', 490, 18);
  drawBar(hud, 490, 24, 140, 18, player.energy, 100, gReady ? '#ffff00' : '#ff6600', '#220011');
  if (gReady) {
    hud.fillStyle = '#ffff00';
    hud.font = 'bold 13px Courier New';
    const flash = Math.floor(Date.now() / 300) % 2 === 0;
    if (flash) hud.fillText('[ E ] READY!!!', 490, 60);
  } else {
    hud.fillStyle = '#ff6600';
    hud.font = 'bold 13px Courier New';
    hud.fillText(Math.floor(player.energy) + '%', 490, 60);
  }

  // KEY indicator
  if (player.hasKey) {
    hud.fillStyle = '#ffdd00';
    hud.font = 'bold 13px Courier New';
    hud.fillText('‚òï KEY', 650, 18);
  }

  // SCORE
  hud.fillStyle = '#888';
  hud.font = 'bold 11px Courier New';
  hud.fillText('SCORE', 650, 50);
  hud.fillStyle = '#fff';
  hud.font = 'bold 14px Courier New';
  hud.fillText(player.score, 650, 68);

  // Controls reminder (small)
  hud.fillStyle = '#444';
  hud.font = '9px Courier New';
  hud.fillText('WASD=Move  G=Grenade  E=Gojira  Space/Click=Shoot', 15, HUD_H - 8);
}

function drawBar(c, x, y, w, h, val, max, fillColor, bgColor) {
  c.fillStyle = bgColor;
  c.fillRect(x, y, w, h);
  c.fillStyle = fillColor;
  const pct = Math.max(0, Math.min(1, val / max));
  c.fillRect(x, y, w * pct, h);
  c.strokeStyle = '#555';
  c.lineWidth = 1;
  c.strokeRect(x, y, w, h);
}

function drawFace(c, x, y, w, h) {
  const hp = player.health;
  const gReady = player.energy >= 100;
  // Background
  c.fillStyle = '#220a00';
  c.fillRect(x, y, w, h);
  c.strokeStyle = '#ff6600';
  c.lineWidth = 2;
  c.strokeRect(x, y, w, h);

  // Skin
  c.fillStyle = hp > 50 ? '#e8b88a' : hp > 25 ? '#c07050' : '#884030';
  c.fillRect(x+10, y+10, w-20, h-20);

  // Hair
  c.fillStyle = '#4a2000';
  c.fillRect(x+10, y+8, w-20, 18);

  // Eyes
  if (gReady) {
    // Manic eyes
    c.fillStyle = '#ffff00';
    c.fillRect(x+20, y+32, 18, 14);
    c.fillRect(x+62, y+32, 18, 14);
    c.fillStyle = '#000';
    c.fillRect(x+26, y+35, 6, 8);
    c.fillRect(x+68, y+35, 6, 8);
  } else if (hp > 60) {
    // Normal
    c.fillStyle = '#fff';
    c.fillRect(x+20, y+32, 18, 12);
    c.fillRect(x+62, y+32, 18, 12);
    c.fillStyle = '#442200';
    c.fillRect(x+25, y+34, 8, 8);
    c.fillRect(x+67, y+34, 8, 8);
  } else if (hp > 30) {
    // Tired - half closed
    c.fillStyle = '#fff';
    c.fillRect(x+20, y+32, 18, 8);
    c.fillRect(x+62, y+32, 18, 8);
    c.fillStyle = '#442200';
    c.fillRect(x+25, y+33, 8, 6);
    c.fillRect(x+67, y+33, 8, 6);
  } else {
    // Bruised - X eyes
    c.fillStyle = '#ff0000';
    c.font = 'bold 14px Courier New';
    c.fillText('X', x+22, y+44);
    c.fillText('X', x+64, y+44);
  }

  // Mouth
  if (gReady) {
    // Big grin
    c.fillStyle = '#ff2200';
    c.fillRect(x+20, y+62, w-40, 10);
    c.fillStyle = '#fff';
    for (let i = 0; i < 5; i++) c.fillRect(x+22+i*13, y+62, 9, 6);
  } else if (hp > 50) {
    c.fillStyle = '#cc4400';
    c.fillRect(x+25, y+64, w-50, 6);
  } else {
    // Frown
    c.fillStyle = '#cc4400';
    c.fillRect(x+25, y+66, w-50, 4);
  }

  // Coffee drip (she's always leaking coffee)
  c.fillStyle = '#6b3200';
  c.fillRect(x+45, y+70, 4, 20);
}

// ‚îÄ‚îÄ WEAPONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let weaponAnim = 0, weaponBob = 0;

function drawWeapon() {
  const cx = W / 2, cy = H - 80;
  const bob = Math.sin(weaponBob) * 5;
  const shooting = player.shootTimer > 0;
  const sx = cx - 60, sy = cy + bob;

  ctx.save();
  // Arm
  ctx.fillStyle = '#e8b88a';
  ctx.fillRect(sx - 10, sy + 30, 25, 50);
  ctx.fillRect(sx + 95, sy + 30, 25, 50);
  // Body/torso hint
  ctx.fillStyle = '#884400';
  ctx.fillRect(sx + 10, sy + 50, 100, 40);

  // Coffee cup / mouth shooting
  ctx.fillStyle = '#6b3200';
  ctx.fillRect(sx + 35, sy + 15, 50, 35);  // cup body
  ctx.fillStyle = '#3d1a00';
  ctx.fillRect(sx + 40, sy + 10, 40, 10);  // rim
  // Coffee liquid
  const coffeeColor = shooting ? '#ff8800' : '#4a1e00';
  ctx.fillStyle = coffeeColor;
  ctx.fillRect(sx + 42, sy + 20, 36, 20);
  // Shoot flash
  if (shooting) {
    ctx.fillStyle = 'rgba(255,120,0,0.7)';
    ctx.fillRect(sx + 30, sy, 60, 20);
    ctx.fillStyle = '#fff';
    ctx.fillRect(sx + 45, sy - 5, 30, 10);
  }
  ctx.restore();
}

function drawGojiraEffect() {
  if (!gojiraActive) return;
  const t = gojiraTimer;
  const phase = t / 120; // 0 to 1

  // Black flash
  if (t > 110) {
    ctx.fillStyle = `rgba(0,0,0,${(120-t)/10})`;
    ctx.fillRect(0, 0, W, H);
    return;
  }

  const gojiraY = H - (phase * (H + 100)) + 50; // rises from bottom

  ctx.save();
  // Screen shake handled in main
  const scale = 0.5 + phase * 0.5;
  const gw = 200 * scale, gh = 250 * scale;
  const gx = W / 2 - gw / 2;
  const gy = Math.min(H - gh * 0.6, gojiraY);

  // Godzilla pixelated 8-bit body
  ctx.fillStyle = '#1a4d1a';
  ctx.fillRect(gx + gw*0.2, gy, gw*0.6, gh*0.8);
  // Head
  ctx.fillStyle = '#0d3300';
  ctx.fillRect(gx + gw*0.25, gy - gh*0.25, gw*0.5, gh*0.25);
  // Dorsal spines
  ctx.fillStyle = '#44ff44';
  for (let i = 0; i < 5; i++) {
    const sw2 = gw * 0.06;
    const sh2 = gh * (0.1 + i * 0.04);
    ctx.fillRect(gx + gw*(0.35 + i*0.07) - sw2/2, gy - sh2, sw2, sh2);
  }
  // Eyes (red)
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(gx + gw*0.32, gy - gh*0.18, gw*0.1, gh*0.08);
  ctx.fillRect(gx + gw*0.58, gy - gh*0.18, gw*0.1, gh*0.08);
  // Tail
  ctx.fillStyle = '#1a4d1a';
  ctx.fillRect(gx + gw*0.75, gy + gh*0.4, gw*0.35, gh*0.12);
  ctx.fillRect(gx + gw*0.9, gy + gh*0.35, gw*0.2, gh*0.08);

  // Atomic breath laser (appears mid-phase)
  if (phase > 0.35) {
    const laserAlpha = Math.min(1, (phase - 0.35) / 0.2);
    const laserY = gy + gh * 0.05;
    // Laser beam going right
    const grad = ctx.createLinearGradient(gx + gw, laserY, W, laserY);
    grad.addColorStop(0, `rgba(100,255,255,${laserAlpha})`);
    grad.addColorStop(0.3, `rgba(0,200,255,${laserAlpha})`);
    grad.addColorStop(1, `rgba(255,100,255,${laserAlpha * 0.3})`);
    ctx.fillStyle = grad;
    const laserH = 25 * scale;
    ctx.fillRect(gx + gw*0.7, laserY - laserH/2, W, laserH);
    // Glow
    ctx.fillStyle = `rgba(100,255,255,${laserAlpha * 0.3})`;
    ctx.fillRect(gx + gw*0.7, laserY - laserH, W, laserH * 2.5);
    // Impact flash on enemies
    if (phase > 0.5 && phase < 0.8) {
      ctx.fillStyle = `rgba(200,255,255,${(phase-0.5)*3})`;
      ctx.fillRect(W * 0.3, 0, W * 0.7, H);
    }
  }
  ctx.restore();

  // Text
  if (phase > 0.2 && phase < 0.7) {
    ctx.fillStyle = `rgba(0,255,255,${Math.sin(phase*Math.PI)})`;
    ctx.font = 'bold 36px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('GOJIRA GO!!!', W/2, 80);
    ctx.textAlign = 'left';
  }
}

// ‚îÄ‚îÄ UPDATE LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let lastTime = 0;
function update(dt) {
  if (!gameRunning || gameWon || gameDead) return;

  // Movement
  let nx = player.x, ny = player.y;
  const cos = Math.cos(player.angle), sin = Math.sin(player.angle);
  const spd = player.speed;

  if (keys['KeyW'] || keys['ArrowUp'])    { nx += cos * spd; ny += sin * spd; }
  if (keys['KeyS'] || keys['ArrowDown'])  { nx -= cos * spd; ny -= sin * spd; }
  if (keys['KeyA'] || keys['ArrowLeft'])  player.angle -= player.rotSpeed;
  if (keys['KeyD'] || keys['ArrowRight']) player.angle += player.rotSpeed;
  if (keys['KeyQ'])  { nx += sin * spd; ny -= cos * spd; }  // strafe left
  if (keys['KeyR'])  { nx -= sin * spd; ny += cos * spd; }  // strafe right
  if (keys['Space']) player.shooting = true; else if (!keys['Space']) {}

  // Collision
  if (mapAt(nx, player.y) === 0) player.x = nx;
  if (mapAt(player.x, ny) === 0) player.y = ny;
  // Door collision (need key)
  const playerTile = mapAt(player.x, player.y);
  if (playerTile === 2 && !player.hasKey) { player.x -= cos*spd; player.y -= sin*spd; }

  weaponBob += 0.1;

  // Shooting
  if (player.shooting && player.shootTimer <= 0) {
    spawnCoffeeProjectile();
    player.shootTimer = 8;
  }
  if (player.shootTimer > 0) player.shootTimer--;

  // Energy recharge
  player.energy = Math.min(100, player.energy + (100 / (60 * 60)) * dt * 60);

  // Grenade timer
  if (player.grenadeTimer > 0) player.grenadeTimer--;

  // Quip timer
  if (quipTimer > 0) { quipTimer--; if (quipTimer === 0) quipBox.style.display = 'none'; }

  // Invincibility
  if (player.invincible > 0) player.invincible--;

  // Update projectiles
  updateProjectiles(dt);

  // Update enemies
  updateEnemies(dt);

  // Pickup collection
  checkPickups();

  // Gojira
  if (gojiraActive) {
    gojiraTimer--;
    if (gojiraTimer <= 0) { gojiraActive = false; }
    // Deal massive damage to all enemies at mid-phase
    if (gojiraTimer === 70) {
      enemies.forEach(e => {
        if (e.alive) {
          e.health -= e.type === 'boss' ? 150 : 999;
          e.state = 'hurt';
          if (e.health <= 0 && e.type !== 'boss') killEnemy(e);
          if (e.type === 'boss' && e.health <= 0) e.health = 1;
        }
      });
      showQuip(laurieQuips_gojira[Math.floor(Math.random()*laurieQuips_gojira.length)], '#00ffff');
    }
  }

  // Check death / win
  if (player.health <= 0 && !gameDead) {
    gameDead = true;
    setTimeout(() => { document.getElementById('gameoverScreen').style.display = 'flex'; }, 500);
  }
}

function spawnCoffeeProjectile() {
  const spd = 0.25;
  projectiles.push({
    x: player.x, y: player.y,
    dx: Math.cos(player.angle) * spd,
    dy: Math.sin(player.angle) * spd,
    type: 'coffee', owner: 'player',
    alive: true, ttl: 80, dot: 3
  });
}

function throwGrenade() {
  if (player.grenades <= 0 || player.grenadeTimer > 0) return;
  player.grenades--;
  player.grenadeTimer = 45;
  const spd = 0.15;
  const gx = player.x, gy = player.y;
  // Explode after 60 frames
  setTimeout(() => {
    if (!gameRunning) return;
    explosions.push({ x: gx + Math.cos(player.angle)*3, y: gy + Math.sin(player.angle)*3, r: 2.5, alpha: 1 });
    enemies.forEach(e => {
      if (!e.alive) return;
      const dx = e.x - (gx + Math.cos(player.angle)*3);
      const dy = e.y - (gy + Math.sin(player.angle)*3);
      const d = Math.sqrt(dx*dx+dy*dy);
      if (d < 3) {
        const dmg = Math.floor((1 - d/3) * (e.type === 'boss' ? 80 : 120));
        e.health -= dmg;
        e.state = 'hurt';
        if (e.health <= 0) killEnemy(e);
      }
    });
    showQuip(laurieQuips_bomb[Math.floor(Math.random()*laurieQuips_bomb.length)], '#ffaa00');
  }, 600);
  showQuip('ü•ñ BAGUETTE AWAY!', '#ffaa00');
}

function activateGojira() {
  if (player.energy < 100 || gojiraActive) return;
  player.energy = 0;
  gojiraActive = true;
  gojiraTimer = 120;
}

function updateProjectiles(dt) {
  projectiles.forEach(p => {
    if (!p.alive) return;
    p.x += p.dx; p.y += p.dy;
    p.ttl--;
    if (p.ttl <= 0 || mapAt(p.x, p.y) !== 0) { p.alive = false; return; }

    if (p.owner === 'player') {
      // Check hit enemies
      enemies.forEach(e => {
        if (!e.alive) return;
        const dx = e.x - p.x, dy = e.y - p.y;
        if (Math.sqrt(dx*dx+dy*dy) < 0.6) {
          const dmg = p.type === 'coffee' ? (8 + Math.floor(Math.random()*5)) : 30;
          e.health -= dmg;
          e.state = 'hurt';
          p.alive = false;
          if (e.health <= 0) killEnemy(e);
          // Boss phase trigger
          if (e.type === 'boss') {
            if (e.health < e.maxHealth * 0.66 && e.phase === 1) {
              e.phase = 2;
              showQuip(trixieQuips[Math.floor(Math.random()*trixieQuips.length)], '#ff2200');
            }
            if (e.health < e.maxHealth * 0.33 && e.phase === 2) {
              e.phase = 3;
              showQuip("You wouldn't like me when I'm angry!", '#ff2200');
            }
          }
        }
      });
    } else {
      // Enemy projectile hits player
      const dx = player.x - p.x, dy = player.y - p.y;
      if (Math.sqrt(dx*dx+dy*dy) < 0.5 && player.invincible <= 0) {
        let dmg = 8;
        if (player.armor > 0) {
          const armorAbs = Math.min(player.armor, dmg * 0.6);
          player.armor -= armorAbs;
          dmg -= armorAbs;
        }
        player.health -= Math.floor(dmg);
        player.invincible = 30;
        p.alive = false;
      }
    }
  });
  projectiles = projectiles.filter(p => p.alive);
}

function killEnemy(e) {
  e.alive = false;
  e.state = 'dead';
  player.score += e.type === 'boss' ? 5000 : e.type === 'spitter' ? 200 : 100;
  if (e.type !== 'boss') {
    showQuip(laurieQuips_kill[Math.floor(Math.random()*laurieQuips_kill.length)], '#ff6600');
  } else {
    // BOSS DEAD
    gameWon = true;
    gameRunning = false;
    showQuip("You're still dead to me.", '#ffffff');
    setTimeout(() => {
      document.getElementById('winScreen').style.display = 'flex';
    }, 3000);
  }
}

function updateEnemies(dt) {
  enemies.forEach(e => {
    if (!e.alive) return;
    const dx = player.x - e.x, dy = player.y - e.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    e.angle = Math.atan2(dy, dx);

    if (e.state === 'hurt') {
      e.moveTimer++;
      if (e.moveTimer > 15) { e.state = 'chase'; e.moveTimer = 0; }
    }

    if (dist < 20) {
      if (e.state === 'idle') e.state = 'chase';
    }

    if (e.state === 'chase' || e.state === 'attack') {
      // Move toward player
      const spd = e.type === 'boss' ? 0.015 : 0.02;
      const ex = e.x + Math.cos(e.angle) * spd;
      const ey = e.y + Math.sin(e.angle) * spd;
      if (mapAt(ex, e.y) === 0) e.x = ex;
      if (mapAt(e.x, ey) === 0) e.y = ey;

      // Melee attack
      if (e.type === 'melee' && dist < 0.8) {
        if (player.invincible <= 0) {
          let dmg = e.type === 'boss' ? 15 : 8;
          if (player.armor > 0) { const abs = Math.min(player.armor, dmg*0.5); player.armor -= abs; dmg -= abs; }
          player.health -= Math.floor(dmg);
          player.invincible = 40;
        }
      }

      // Ranged attack
      e.shootTimer--;
      const shootInterval = e.type === 'boss' ? (e.phase >= 2 ? 30 : 50) : 90;
      if (e.shootTimer <= 0 && dist < 12) {
        e.shootTimer = shootInterval + Math.random() * 20;
        if (e.type === 'spitter' || e.type === 'boss') {
          const spd2 = e.type === 'boss' ? 0.12 : 0.1;
          // Slight spread for boss
          const spread = e.type === 'boss' ? (Math.random()-0.5)*0.3 : 0;
          projectiles.push({
            x: e.x, y: e.y,
            dx: Math.cos(e.angle+spread) * spd2,
            dy: Math.sin(e.angle+spread) * spd2,
            type: 'needle', owner: 'enemy',
            alive: true, ttl: 100
          });
          // Boss phase 2: extra projectiles
          if (e.type === 'boss' && e.phase >= 2) {
            for (let i = 0; i < 2; i++) {
              const a = e.angle + (Math.random()-0.5)*0.6;
              projectiles.push({ x: e.x, y: e.y, dx: Math.cos(a)*0.1, dy: Math.sin(a)*0.1, type: 'needle', owner: 'enemy', alive: true, ttl: 100 });
            }
          }
          // Random trixie quip
          if (e.type === 'boss' && Math.random() < 0.05) {
            showQuip(trixieQuips[Math.floor(Math.random()*trixieQuips.length)], '#ff2200');
          }
          // Boss phase 3: spawn minions
          if (e.type === 'boss' && e.phase >= 3 && e.spawnTimer <= 0) {
            const ang = Math.random() * Math.PI * 2;
            enemies.push(makeEnemy(e.x + Math.cos(ang)*2, e.y + Math.sin(ang)*2, 'melee'));
            e.spawnTimer = 200;
          }
          if (e.spawnTimer > 0) e.spawnTimer--;
        }
      }
    }
  });
}

function checkPickups() {
  pickups.forEach(p => {
    if (!p.alive) return;
    const dx = player.x - p.x, dy = player.y - p.y;
    if (Math.sqrt(dx*dx+dy*dy) < 0.7) {
      p.alive = false;
      if (p.type === 'health') { player.health = Math.min(100, player.health + 25); showQuip('Coffee heals... somehow.', '#00ff88'); }
      if (p.type === 'grenade') { player.grenades += 3; showQuip('More bread!', '#ffaa00'); }
      if (p.type === 'armor') { player.armor = Math.min(100, player.armor + 30); showQuip('Armored up!', '#4488ff'); }
      if (p.type === 'key') { player.hasKey = true; showQuip('‚òï Coffee Mug Key acquired!', '#ffdd00'); }
    }
  });
}

// ‚îÄ‚îÄ DRAW PROJECTILES (on canvas) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawProjectiles() {
  projectiles.forEach(p => {
    if (!p.alive) return;
    const dx = p.x - player.x, dy = p.y - player.y;
    const angle = Math.atan2(dy, dx) - player.angle;
    let a = angle;
    while (a > Math.PI) a -= 2*Math.PI;
    while (a < -Math.PI) a += 2*Math.PI;
    if (Math.abs(a) > player.fov) return;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 0.3) return;
    const screenX = (0.5 + a / player.fov) * W;
    const size = PROJ_DIST * 0.08 / dist;
    const sy = HALF_H - size/2;
    const col = p.type === 'coffee' ? '#ff8800' : '#88ff44';
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(screenX, HALF_H, Math.max(2, size), 0, Math.PI*2);
    ctx.fill();
  });
}

function drawExplosions() {
  explosions.forEach(ex => {
    const dx = ex.x - player.x, dy = ex.y - player.y;
    const angle = Math.atan2(dy, dx) - player.angle;
    let a = angle;
    while (a > Math.PI) a -= 2*Math.PI;
    while (a < -Math.PI) a += 2*Math.PI;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const screenX = (0.5 + a / player.fov) * W;
    const size = PROJ_DIST * ex.r / Math.max(0.5, dist);
    ctx.globalAlpha = ex.alpha;
    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    ctx.arc(screenX, HALF_H, size, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ex.alpha -= 0.03;
    ex.r += 0.05;
  });
  explosions = explosions.filter(e => e.alpha > 0);
}

// Damage flash
let damageFlash = 0;
const origInvincible = player.invincible;
function checkDamageFlash() {
  if (player.invincible > 0 && player.invincible < 30) {
    ctx.fillStyle = `rgba(255,0,0,${player.invincible/60})`;
    ctx.fillRect(0, 0, W, H);
  }
}

// ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loop(ts = 0) {
  if (!gameRunning && !gameWon && !gameDead) return;
  const dt = Math.min(2, (ts - lastTime) / (1000/60));
  lastTime = ts;

  update(dt);

  // Render
  castRays();
  drawSprites();
  drawProjectiles();
  drawExplosions();
  checkDamageFlash();
  drawWeapon();
  if (gojiraActive) drawGojiraEffect();
  drawHUD();

  requestAnimationFrame(loop);
}
</script>
</body>
</html>